<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Ripplix Animation Library</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: #333;
            background-color: #f9f9f9;
            /* Allow scrolling while keeping Figma's close button hidden */
            overflow-x: hidden;
            /* Only hide horizontal overflow */
        }
        /* Hide figma's default close button if it exists */
        
        #figma-x-button,
        .figma-x-button {
            display: none !important;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background-color: white;
            border-bottom: none;
            position: relative;
        }
        
        .logo-container {
            display: flex;
            align-items: center;
        }
        
        .logo {
            height: 32px;
        }
        
        .stats {
            display: flex;
            align-items: center;
            gap: 16px;
            position: relative;
        }
        
        .ref-count {
            color: #333;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
        }
        
        .sparkle-icon {
            color: #FFC107;
            margin-right: 8px;
            font-size: 20px;
        }
        
        .support-btn {
            background-color: #f3f3f3;
            color: #14114B;
            border: none;
            border-radius: 50px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        }
        
        .close-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 16px;
            margin-left: 16px;
            color: #333;
        }
        
        .search-and-filters {
            padding: 0 16px 16px;
            background-color: white;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .search-row {
            display: flex;
            margin-bottom: 16px;
            gap: 16px;
        }
        
        .search-label {
            font-size: 14px;
            font-weight: 500;
            color: #333;
            margin-bottom: 8px;
        }
        
        .platform-label {
            font-size: 14px;
            font-weight: 500;
            color: #333;
            margin-bottom: 8px;
        }
        
        .search-container {
            margin-bottom: 0;
            position: relative;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        
        .search-input {
            width: 100%;
            padding: 10px 12px;
            padding-right: 40px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: #f9f9f9;
        }
        
        .search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            color: #2962ff;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 9px;
            /* Adjust to align with the input field */
        }
        
        .platform-dropdown {
            position: relative;
            min-width: 160px;
        }
        
        .platform-select {
            width: 100%;
            padding: 10px 12px;
            padding-right: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 14px;
            background-color: #f9f9f9;
            appearance: none;
            cursor: pointer;
            color: #333;
        }
        
        .dropdown-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: #555;
            margin-top: 9px;
            /* Adjust to align with the select field */
        }
        
        .filters {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }
        
        .filter-tag {
            padding: 8px 16px;
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 50px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            color: #333;
        }
        
        .filter-tag.active {
            background-color: #14114B;
            color: white;
            border-color: #14114B;
        }
        
        .animation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 16px;
            padding: 16px;
        }
        
        .animation-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100%;
        }
        
        .animation-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }
        
        .video-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            background-color: #f0f0f0;
            overflow: hidden;
        }
        
        .loading-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
            z-index: 1;
        }
        
        .animation-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 2;
        }
        
        .play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .play-overlay.show-play {
            opacity: 1;
        }
        
        .play-icon {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .product-section {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .product-logo-container {
            width: 24px;
            height: 24px;
            min-width: 24px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .product-logo {
            width: 100%;
            height: 100%;
            border-radius: 4px;
            object-fit: contain;
            background-color: #f9f9f9;
            transition: opacity 0.2s ease;
        }
        
        .product-logo-placeholder {
            background-color: #f0f0f0;
            padding: 2px;
        }
        
        .product-logo-loaded {
            opacity: 1;
        }
        
        .product-name {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .interaction-container {
            padding: 12px 16px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .interaction-tag {
            display: inline-block;
            padding: 4px 10px;
            background-color: #f5f5f5;
            border-radius: 16px;
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }
        
        .add-button {
            margin: auto 16px 16px;
            padding: 10px 16px;
            border-radius: 8px;
            background-color: #2962ff;
            color: white;
            font-weight: 600;
            text-align: center;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .add-button:hover {
            background-color: #0039cb;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
            font-size: 16px;
            color: #666;
        }
        
        @media (max-width: 768px) {
            .filter-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .filter-label {
                width: 100%;
                margin-bottom: 4px;
            }
        }
        
        .api-error-message {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 32px;
            margin: 32px auto;
            max-width: 480px;
            text-align: center;
            border-radius: 8px;
            background-color: #FFEBEE;
            border: 1px solid #FFCDD2;
        }
        
        .error-icon {
            margin-bottom: 16px;
        }
        
        .api-error-message h3 {
            color: #D32F2F;
            margin: 0 0 12px 0;
            font-size: 20px;
        }
        
        .api-error-message p {
            margin: 0 0 8px 0;
            color: #424242;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .support-message {
            margin-top: 16px !important;
            font-weight: 500;
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="logo-container">
            <img src="https://www.ripplix.com/wp-content/uploads/2024/12/Logo-of-Ripplix-Retina.svg" alt="Ripplix" class="logo">
        </div>
        <div class="stats">
            <div class="ref-count"><span class="sparkle-icon">✨</span><span id="animation-count">0</span> Ref. Added</div>
            <button class="support-btn">Support Us</button>
            <button class="close-btn" id="close-btn">✕</button>
        </div>
    </div>

    <div class="search-and-filters">
        <div class="search-row">
            <div class="search-container">
                <div class="search-label">Search for inspirations</div>
                <input type="text" id="search-input" class="search-input" placeholder="Hover effect, loading">
                <div class="search-icon">🔍</div>
            </div>

            <div class="platform-dropdown">
                <div class="platform-label">Platform</div>
                <select id="platform-select" class="platform-select">
                    <option value="">All</option>
                    <option value="Web App">Web App</option>
                    <option value="Mobile App">Mobile App</option>
                    <option value="Wearables">Wearables</option>
                    <option value="Website">Website</option>
                    <option value="XR / AR / VR">XR / AR / VR</option>
                </select>
                <div class="dropdown-icon">▼</div>
            </div>
        </div>

        <div class="filters" id="filter-container">
            <span class="filter-tag" data-filter="interaction" data-value="Hover">Hover</span>
            <span class="filter-tag" data-filter="interaction" data-value="Drop down">Drop down</span>
            <span class="filter-tag" data-filter="interaction" data-value="Popup">Popup</span>
            <span class="filter-tag" data-filter="interaction" data-value="Loading">Loading</span>
            <span class="filter-tag" data-filter="interaction" data-value="Tooltip">Tooltip</span>
            <span class="filter-tag" data-filter="interaction" data-value="Toggle">Toggle</span>
        </div>
    </div>

    <div id="loading-indicator" class="loading">Loading animations from Ripplix API...</div>
    <div id="animations-container">
        <!-- This will be populated with animations -->
    </div>

    <div id="preview-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.7); z-index: 100; justify-content: center; align-items: center;">
        <div style="background-color: white; border-radius: 8px; width: 80%; max-width: 600px; overflow: visible; position: relative;">
            <button id="preview-close" style="position: absolute; top: 12px; right: 12px; background: transparent; border: none; font-size: 20px; cursor: pointer;">✕</button>
            <div style="padding: 16px; border-bottom: 1px solid #e0e0e0;">
                <h2 id="preview-title" style="margin: 0 0 8px 0; color: #14114B;"></h2>
                <div id="preview-meta" style="display: flex; gap: 8px;"></div>
            </div>
            <div class="video-wrapper" style="padding: 16px;"></div>
            <div style="padding: 16px; border-top: 1px solid #e0e0e0;">
                <button id="preview-add" style="background-color: #14114B; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Add to Figma</button>
            </div>
        </div>
    </div>

    <script>
        // Set up global variables
        let allAnimations = [];
        let activeFilters = {
            platform: null,
            interaction: null
        };
        let paginationState = {
            itemsPerPage: 12,
            currentPage: 1,
            isLoading: false
        };

        // DOM ready handler
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM loaded, initializing plugin");

            // Show loading state
            const loadingIndicator = document.getElementById('loading-indicator');
            loadingIndicator.style.display = 'flex';

            const container = document.getElementById('animations-container');
            container.innerHTML = '';

            // Initialize animation count to 0
            document.getElementById('animation-count').textContent = '0';

            // Fetch animations from API
            fetchAnimationsFromApi();

            // Set up event handlers
            setupEventHandlers();

            // Set up scroll listener for pagination
            setupScrollListener();
        });

        // Fetch animations from API
        async function fetchAnimationsFromApi() {
            console.log("Fetching animations from API");

            // Show loading indicator
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'flex';
            }

            // Try multiple API endpoints to find which one works
            const apiEndpoints = [
                'https://www.ripplix.com/wp-json/ripplix/v1/animations/',
                'https://ripplix.com/wp-json/ripplix/v1/animations'
            ];

            // Log the start of API fetch
            console.log(`Attempting to fetch from ${apiEndpoints.length} possible endpoints`);

            let successfulFetch = false;
            let finalData = null;
            let finalError = null;

            // Try each endpoint
            for (let i = 0; i < apiEndpoints.length; i++) {
                const apiUrl = apiEndpoints[i];
                console.log(`Trying endpoint ${i+1}: ${apiUrl}`);

                // Set up request timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 second timeout

                try {
                    // Fetch from the Ripplix API with proper headers
                    console.log(`Making API request to ${apiUrl}...`);
                    const response = await fetch(apiUrl, {
                        signal: controller.signal,
                        method: 'GET',
                        mode: 'cors',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                        },
                        credentials: 'omit' // Don't send cookies
                    });

                    clearTimeout(timeoutId);

                    console.log(`API response status from ${apiUrl}:`, response.status);

                    // Clone the response for debugging
                    const responseClone = response.clone();
                    const responseText = await responseClone.text();
                    console.log(`API response text (first 200 chars): ${responseText.substring(0, 200)}...`);

                    if (!response.ok) {
                        console.error(`Endpoint ${apiUrl} failed with status: ${response.status}`);
                        continue; // Try next endpoint
                    }

                    // Parse the response
                    let data;
                    try {
                        data = JSON.parse(responseText);
                        console.log(`Successfully parsed JSON from ${apiUrl}`);
                    } catch (parseError) {
                        console.error(`JSON parse error from ${apiUrl}:`, parseError);
                        console.log("Response was not valid JSON, continuing to next endpoint");
                        continue; // Try next endpoint
                    }

                    // Check if we received any data
                    if (!data) {
                        console.error(`${apiUrl} returned null or undefined data`);
                        continue; // Try next endpoint
                    }

                    console.log(`Data structure from ${apiUrl}:`, Object.keys(data));

                    // Process different API response formats
                    if (Array.isArray(data)) {
                        // Direct array of animations
                        console.log(`${apiUrl} returned direct array of ${data.length} animations`);
                        if (data.length > 0) {
                            console.log(`First animation:`, data[0]);
                            finalData = {
                                animations: data
                            };
                            successfulFetch = true;
                            break; // Found working endpoint
                        }
                    } else if (data.animations && Array.isArray(data.animations)) {
                        // Object with animations array
                        console.log(`${apiUrl} returned object with ${data.animations.length} animations`);
                        if (data.animations.length > 0) {
                            console.log(`First animation:`, data.animations[0]);
                            finalData = data;
                            successfulFetch = true;
                            break; // Found working endpoint
                        }
                    } else {
                        console.error(`${apiUrl} returned unexpected data structure`);
                        console.log(`Data keys: ${Object.keys(data).join(', ')}`);
                        continue; // Try next endpoint
                    }
                } catch (error) {
                    console.error(`Error fetching from ${apiUrl}:`, error);
                    finalError = error;
                    continue; // Try next endpoint
                }
            }

            // Process results
            if (successfulFetch && finalData) {
                console.log(`Successfully fetched animation data`);
                processApiData(finalData);
            } else {
                console.error("All API endpoints failed");

                // Display error message
                let errorMessage = "Failed to load animation data from the server.";

                if (finalError) {
                    if (finalError.name === "AbortError") {
                        errorMessage = "Request timed out. Please check your internet connection and try again.";
                    } else if (finalError.message.includes("status: 4")) {
                        errorMessage = "Server returned an error. The API may be temporarily unavailable.";
                    } else if (finalError.message.includes("status: 5")) {
                        errorMessage = "Server error. The Ripplix API is currently experiencing issues.";
                    }
                }

                console.error(errorMessage);
                showApiError(`${errorMessage} Please try again later or contact support@ripplix.com with ID range starting from 2051.`);
            }
        }

        // Process API data and create grid
        function processApiData(apiData) {
            // Check if we have valid data
            if (!apiData || !apiData.animations || !Array.isArray(apiData.animations) || apiData.animations.length === 0) {
                console.error("API returned invalid or empty data");
                showApiError("No valid animation data could be retrieved from the API");
                return;
            }

            console.log("Processing API data with", apiData.animations.length, "animations");

            // Accept all animations without filtering by product name
            // We just need to ensure the data structure is valid

            // Validate and transform API data to our format
            const validAnimations = apiData.animations
                .filter(item => {
                    // Basic validation of required fields
                    if (!item.id) {
                        console.log(`Filtering out animation without ID`);
                        return false;
                    }

                    // Keep only items with valid video URLs
                    if (!item.video_url || !isValidUrl(item.video_url)) {
                        console.log(`Filtering out animation with invalid video URL: ${item.id}`);
                        return false;
                    }

                    return true;
                })
                .map(item => {
                    // Get the first interaction type if multiple exist
                    const interaction = Array.isArray(item.interaction) && item.interaction.length > 0 ?
                        item.interaction[0] :
                        (typeof item.interaction === 'string' ? item.interaction : "Animation");

                    // Fix Cloudflare URLs
                    let videoUrl = item.video_url;
                    if (videoUrl && videoUrl.includes('cloudflarestream')) {
                        videoUrl = fixCloudflareUrl(videoUrl);
                    }

                    return {
                        id: item.id.toString(),
                        title: item.title || 'Untitled Animation',
                        platform: item.platform || 'Web App',
                        interaction: interaction,
                        description: item.description || `${item.title || 'Animation'} - ${interaction} animation`,
                        url: item.url || '',
                        video_url: videoUrl || '',
                        product: item.product || 'Ripplix',
                        industry: item.industry || '',
                        product_logo: item.product_logo || ''
                    };
                });

            // Remove duplicate animations
            const uniqueAnimations = removeDuplicateAnimations(validAnimations);

            // Log the duplicate removal statistics
            console.log(`Removed ${validAnimations.length - uniqueAnimations.length} duplicate animations`);

            // Log the ID range for debugging
            if (uniqueAnimations.length > 0) {
                const ids = uniqueAnimations.map(a => parseInt(a.id)).sort((a, b) => a - b);
                console.log(`Animation ID range: ${ids[0]} to ${ids[ids.length - 1]}`);
            }

            // Check if we have any valid animations after filtering
            if (uniqueAnimations.length === 0) {
                console.error("No valid animations found after filtering");
                showApiError("No valid animations found. The data may be corrupted or invalid.");
                return;
            }

            // Set the global animations array
            allAnimations = uniqueAnimations;

            // Create grid with the transformed animations
            createAnimationGrid(allAnimations);

            // Update the animation count display
            const countEl = document.getElementById('animation-count');
            if (countEl) {
                countEl.textContent = allAnimations.length.toString();
            }

            // Set up sorting
            setupSorting();

            // Set up filter UI
            setupFilters(apiData);
        }

        // Remove duplicate animations based on ID and title
        function removeDuplicateAnimations(animations) {
            console.log(`Checking for duplicates among ${animations.length} animations`);

            // Track unique IDs to filter out duplicates
            const seenIds = new Set();
            const seenTitles = new Map();
            const duplicates = [];

            // Filter out duplicates
            const uniqueAnimations = animations.filter(animation => {
                // Use ID as primary key for deduplication
                if (seenIds.has(animation.id)) {
                    duplicates.push({
                        id: animation.id,
                        title: animation.title,
                        reason: 'duplicate ID'
                    });
                    return false;
                }

                // Also check for duplicates by title and product
                const titleKey = `${animation.title}-${animation.product}`.toLowerCase();
                if (seenTitles.has(titleKey)) {
                    // This is likely a duplicate with a different ID
                    console.log(`Potential duplicate: "${animation.title}" - ID ${animation.id} vs ${seenTitles.get(titleKey)}`);
                    duplicates.push({
                        id: animation.id,
                        title: animation.title,
                        reason: 'duplicate title',
                        originalId: seenTitles.get(titleKey)
                    });
                    return false;
                }

                // This is a unique animation
                seenIds.add(animation.id);
                seenTitles.set(titleKey, animation.id);
                return true;
            });

            // Log duplicates for debugging
            if (duplicates.length > 0) {
                console.log(`Removed ${duplicates.length} duplicate animations:`, duplicates.slice(0, 5));
                if (duplicates.length > 5) {
                    console.log(`...and ${duplicates.length - 5} more duplicates`);
                }
            }

            return uniqueAnimations;
        }

        // Display API error message
        function showApiError(message) {
            // Hide loading indicator
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }

            // Get container and clear it
            const container = document.getElementById('animations-container');
            container.innerHTML = '';

            // Create error message element
            const errorDiv = document.createElement('div');
            errorDiv.className = 'api-error-message';

            // Create error icon
            const errorIcon = document.createElement('div');
            errorIcon.className = 'error-icon';
            errorIcon.innerHTML = '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm-1-7v2h2v-2h-2zm0-8v6h2V7h-2z" fill="#D32F2F"/></svg>';
            errorDiv.appendChild(errorIcon);

            // Create error title
            const errorTitle = document.createElement('h3');
            errorTitle.textContent = 'Error Loading Animations';
            errorDiv.appendChild(errorTitle);

            // Create error message
            const errorMessage = document.createElement('p');
            errorMessage.textContent = message;
            errorDiv.appendChild(errorMessage);

            // Create contact support message
            const supportMessage = document.createElement('p');
            supportMessage.className = 'support-message';
            supportMessage.textContent = 'Please contact support@ripplix.com for assistance.';
            errorDiv.appendChild(supportMessage);

            // Add error message to container
            container.appendChild(errorDiv);

            // Update animation count to 0
            const countEl = document.getElementById('animation-count');
            if (countEl) {
                countEl.textContent = '0';
            }
        }

        // Update platform dropdown with API data
        function updatePlatformDropdown(platforms) {
            const platformSelect = document.getElementById('platform-select');
            if (!platformSelect) return;

            // Clear existing options except the first "All" option
            while (platformSelect.options.length > 1) {
                platformSelect.remove(1);
            }

            // Add new platform options
            platforms.forEach(platform => {
                const option = document.createElement('option');
                option.value = platform;
                option.textContent = platform;
                platformSelect.appendChild(option);
            });
        }

        // Fix Cloudflare URL to direct download
        function fixCloudflareUrl(url) {
            console.log("Fixing Cloudflare URL:", url);

            // If already in the correct format, return as is
            if (url.includes('/downloads/default.mp4')) {
                console.log("URL already has /downloads/default.mp4 format, using as is");
                return url;
            }

            // Extract the video ID using regex pattern for 32-character hex IDs
            const hexPattern = /([a-f0-9]{32})/i;
            const matches = url.match(hexPattern);

            if (matches && matches[1]) {
                const videoId = matches[1];
                console.log("Extracted video ID:", videoId);
                const directUrl = `https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/${videoId}/downloads/default.mp4`;
                console.log("Generated direct download URL:", directUrl);
                return directUrl;
            }

            console.warn("Could not extract video ID from URL, using original:", url);
            return url;
        }

        // Create animation grid
        function createAnimationGrid(animations) {
            console.log(`Creating animation grid with ${animations.length} animations`);

            // Get container and clear it
            const container = document.getElementById('animations-container');
            container.innerHTML = '';

            // Hide loading indicator
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }

            // Handle empty state
            if (!animations || animations.length === 0) {
                container.innerHTML = '<div class="loading">No animations found</div>';
                return;
            }

            // Create grid
            const grid = document.createElement('div');
            grid.className = 'animation-grid';
            grid.id = 'animation-grid';

            // Reset pagination state
            paginationState.currentPage = 1;
            paginationState.isLoading = false;

            // Initial load - only show first page of animations
            const initialAnimations = getVisibleAnimations();
            console.log(`Displaying initial ${initialAnimations.length} animations`);

            // Add animation cards for initial page
            initialAnimations.forEach(animation => {
                const card = createAnimationCard(animation);
                grid.appendChild(card);
            });

            // Add grid to container
            container.appendChild(grid);

            // Add loading indicator that will show when loading more
            const loadingMore = document.createElement('div');
            loadingMore.className = 'loading';
            loadingMore.id = 'loading-more';
            loadingMore.style.display = 'none';
            loadingMore.textContent = 'Loading more animations...';
            container.appendChild(loadingMore);

            console.log("Animation grid created with initial animations");

            // Initialize lazy loading
            initLazyLoading();
        }

        // Create a single animation card
        function createAnimationCard(animation) {
            // Create card element
            const card = document.createElement('div');
            card.className = 'animation-card';

            // 1. Video container
            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-container';

            // Add loading text
            const loadingText = document.createElement('div');
            loadingText.className = 'loading-text';
            loadingText.textContent = 'Loading...';
            videoContainer.appendChild(loadingText);

            // Create video element
            const video = document.createElement('video');
            video.className = 'animation-video';
            video.src = animation.video_url;
            video.muted = true;
            video.loop = true;
            video.playsInline = true;
            video.loading = 'lazy';

            // Add play overlay
            const playOverlay = document.createElement('div');
            playOverlay.className = 'play-overlay';

            const playIcon = document.createElement('div');
            playIcon.className = 'play-icon';
            playIcon.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 5V19L19 12L8 5Z" fill="white"/></svg>';
            playOverlay.appendChild(playIcon);

            videoContainer.appendChild(video);
            videoContainer.appendChild(playOverlay);

            // Handle video events
            video.addEventListener('loadeddata', () => {
                loadingText.style.display = 'none';
                video.play().catch(err => {
                    // Show play button if autoplay fails
                    playOverlay.classList.add('show-play');
                });
            });

            video.addEventListener('error', () => {
                // Show play button if video fails to load
                loadingText.textContent = 'Video failed to load';
                playOverlay.classList.add('show-play');
            });

            video.addEventListener('play', () => {
                playOverlay.classList.remove('show-play');
            });

            video.addEventListener('pause', () => {
                playOverlay.classList.add('show-play');
            });

            // Handle click event for video container
            videoContainer.addEventListener('click', (event) => {
                if (video.paused) {
                    video.play().catch(err => console.error('Play error:', err));
                } else {
                    video.pause();
                }
            });

            // 2. Product section
            const productSection = document.createElement('div');
            productSection.className = 'product-section';

            // Add product logo if available
            if (animation.product_logo && animation.product_logo.trim() && isValidUrl(animation.product_logo)) {
                const logoContainer = document.createElement('div');
                logoContainer.className = 'product-logo-container';

                const logoImg = document.createElement('img');
                logoImg.className = 'product-logo';
                logoImg.src = animation.product_logo;
                logoImg.alt = animation.product || 'Product logo';
                logoImg.width = 24;
                logoImg.height = 24;

                // Handle error for any image format
                logoImg.onerror = function() {
                    // Remove the logo container completely if the image fails to load
                    const container = this.closest('.product-logo-container');
                    if (container) {
                        container.remove();
                    }
                };

                // Ensure image is loaded properly
                logoImg.onload = function() {
                    this.classList.add('product-logo-loaded');
                };

                logoContainer.appendChild(logoImg);
                productSection.appendChild(logoContainer);
            } else {
                // Add a spacer to maintain consistent layout if there's no logo
                const spacer = document.createElement('div');
                spacer.className = 'product-logo-spacer';
                spacer.style.width = '8px'; // Small spacer
                productSection.appendChild(spacer);
            }

            // Add product name (using product field as product name per API)
            const productName = document.createElement('div');
            productName.className = 'product-name';
            productName.textContent = animation.product || 'Untitled Product';
            productSection.appendChild(productName);

            // 3. Interaction container
            const interactionContainer = document.createElement('div');
            interactionContainer.className = 'interaction-container';

            // Handle both single string and array of interactions
            let interactions = [];
            if (typeof animation.interaction === 'string') {
                interactions = [animation.interaction];
            } else if (Array.isArray(animation.interaction)) {
                interactions = animation.interaction;
            }

            // Create tags for each interaction
            interactions.forEach(interaction => {
                if (interaction && interaction.trim()) {
                    const tag = document.createElement('span');
                    tag.className = 'interaction-tag';
                    tag.textContent = interaction.trim();
                    interactionContainer.appendChild(tag);
                }
            });

            // 4. Add to Figma button
            const addButton = document.createElement('button');
            addButton.className = 'add-button';
            addButton.textContent = 'Add to Figma';
            addButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent card click
                addToFigma(animation);
            });

            // Assemble card
            card.appendChild(videoContainer);
            card.appendChild(productSection);
            card.appendChild(interactionContainer);
            card.appendChild(addButton);

            // Add click event to show preview modal (unless add button is clicked)
            card.addEventListener('click', (event) => {
                if (!event.target.closest('.add-button')) {
                    showPreviewModal(animation);
                }
            });

            return card;
        }

        // Get currently visible animations based on pagination and filters
        function getVisibleAnimations() {
            // Apply filters first
            const filteredAnimations = allAnimations.filter(animation => {
                // Check if animation matches all active filters
                const matchesPlatform = !activeFilters.platform || animation.platform === activeFilters.platform;

                // For interaction, check if it's in the array or matches the string
                let matchesInteraction = true;
                if (activeFilters.interaction) {
                    if (Array.isArray(animation.interaction)) {
                        matchesInteraction = animation.interaction.includes(activeFilters.interaction);
                    } else {
                        matchesInteraction = animation.interaction === activeFilters.interaction;
                    }
                }

                // Get search query
                const searchInput = document.getElementById('search-input');
                const query = searchInput ? searchInput.value.toLowerCase() : '';

                // Check if animation matches search query
                const matchesSearch = !query ||
                    animation.title.toLowerCase().includes(query) ||
                    (animation.platform && animation.platform.toLowerCase().includes(query)) ||
                    (Array.isArray(animation.interaction) ?
                        animation.interaction.some(i => i.toLowerCase().includes(query)) :
                        (animation.interaction && animation.interaction.toLowerCase().includes(query))) ||
                    (animation.description && animation.description.toLowerCase().includes(query));

                return matchesPlatform && matchesInteraction && matchesSearch;
            });

            // Apply pagination
            const startIndex = 0;
            const endIndex = paginationState.currentPage * paginationState.itemsPerPage;

            const visibleAnimations = filteredAnimations.slice(startIndex, endIndex);
            console.log(`Visible animations: ${visibleAnimations.length} of ${filteredAnimations.length} filtered animations`);

            return visibleAnimations;
        }

        // Load more animations
        function loadMoreAnimations() {
            if (paginationState.isLoading) {
                return; // Prevent multiple simultaneous loads
            }

            paginationState.isLoading = true;
            console.log(`Loading more animations, page ${paginationState.currentPage + 1}`);

            // Show loading indicator
            const loadingMore = document.getElementById('loading-more');
            if (loadingMore) {
                loadingMore.style.display = 'flex';
            }

            // Simulate network delay for smoother UX (optional, can be removed)
            setTimeout(() => {
                // Increment page
                paginationState.currentPage++;

                // Get animations for current page
                const currentAnimations = getVisibleAnimations();
                const grid = document.getElementById('animation-grid');

                if (grid) {
                    // Get current animation IDs to avoid duplicates
                    const existingIds = Array.from(grid.querySelectorAll('.animation-card'))
                        .map(card => card.dataset.animationId);

                    // Create and add new cards for animations not already in the grid
                    currentAnimations.forEach(animation => {
                        if (!existingIds.includes(animation.id.toString())) {
                            const card = createAnimationCard(animation);
                            grid.appendChild(card);
                        }
                    });

                    // Reinitialize lazy loading for new cards
                    initLazyLoading();
                }

                // Hide loading indicator
                if (loadingMore) {
                    loadingMore.style.display = 'none';
                }

                paginationState.isLoading = false;

                // Check if we've loaded all animations
                const filteredCount = allAnimations.filter(animation => {
                    const matchesPlatform = !activeFilters.platform || animation.platform === activeFilters.platform;
                    const matchesInteraction = !activeFilters.interaction || animation.interaction === activeFilters.interaction;
                    const searchInput = document.getElementById('search-input');
                    const query = searchInput ? searchInput.value.toLowerCase() : '';
                    const matchesSearch = !query ||
                        animation.title.toLowerCase().includes(query) ||
                        (animation.platform && animation.platform.toLowerCase().includes(query)) ||
                        (animation.interaction && animation.interaction.toLowerCase().includes(query)) ||
                        (animation.description && animation.description.toLowerCase().includes(query));
                    return matchesPlatform && matchesInteraction && matchesSearch;
                }).length;

                console.log(`Loaded ${grid.querySelectorAll('.animation-card').length} of ${filteredCount} animations`);
            }, 300);
        }

        // Set up scroll listener for pagination
        function setupScrollListener() {
            console.log("Setting up scroll listener for pagination");

            // Function to check scroll position and load more if needed
            function checkScrollPosition() {
                if (paginationState.isLoading) return;

                // Check if we're near bottom of the page
                const scrollPosition = window.scrollY + window.innerHeight;
                const totalHeight = document.body.offsetHeight;
                const threshold = 200; // Load more when within 200px of bottom

                if (scrollPosition + threshold >= totalHeight) {
                    console.log("Near bottom of page, loading more animations");
                    loadMoreAnimations();
                }
            }

            // Throttle scroll event to avoid performance issues
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                if (scrollTimeout) clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(checkScrollPosition, 100);
            });

            // Also check on resize
            window.addEventListener('resize', () => {
                if (scrollTimeout) clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(checkScrollPosition, 100);
            });

            // Initial check in case the content doesn't fill the page
            setTimeout(checkScrollPosition, 500);
        }

        // Load video for container
        function loadVideoForContainer(container) {
            // Check if video is already loaded
            if (container.querySelector('video')) {
                const existingVideo = container.querySelector('video');
                existingVideo.play().catch(err => {
                    console.error(`Failed to play video: ${err}`);
                    container.querySelector('.play-overlay').classList.add('show-play');
                });
                return;
            }

            const videoUrl = container.dataset.videoUrl;
            const animationId = container.dataset.animationId;

            if (!videoUrl) {
                console.error(`No video URL for animation ID: ${animationId}`);
                return;
            }

            console.log(`Loading video for animation ID: ${animationId}, URL: ${videoUrl}`);

            // Create video element
            const video = document.createElement('video');
            video.className = 'animation-video';
            video.src = videoUrl;
            video.muted = true;
            video.loop = true;
            video.playsInline = true;
            video.setAttribute('playsinline', '');

            // Remove loading text when video loads
            video.onloadeddata = () => {
                const loadingText = container.querySelector('.loading-text');
                if (loadingText) loadingText.remove();
                video.play().catch(err => {
                    console.error(`Failed to autoplay video for animation ID: ${animationId}`, err);
                    container.querySelector('.play-overlay').classList.add('show-play');
                });
            };

            // Show play button when video is paused
            video.onpause = () => {
                container.querySelector('.play-overlay').classList.add('show-play');
            };

            // Hide play button when video is playing
            video.onplay = () => {
                container.querySelector('.play-overlay').classList.remove('show-play');
            };

            video.onerror = () => {
                console.error(`Error loading video for animation ID: ${animationId}`);
                container.querySelector('.loading-text').textContent = 'Error loading video';
                container.querySelector('.play-overlay').classList.add('show-play');
            };

            container.appendChild(video);
        }

        // Initialize videos with IntersectionObserver for lazy loading
        function initVideos() {
            const options = {
                root: null,
                rootMargin: '0px',
                threshold: 0.1
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const container = entry.target;
                        loadVideoForContainer(container);
                        observer.unobserve(container);
                    }
                });
            }, options);

            // Observe all video containers
            document.querySelectorAll('.video-container').forEach(container => {
                observer.observe(container);
            });
        }

        // Initialize lazy loading for videos
        function initLazyLoading() {
            console.log("Initializing lazy loading for videos");

            // Create IntersectionObserver
            const options = {
                root: null, // use viewport
                rootMargin: '100px', // load when within 100px of viewport
                threshold: 0.1 // trigger when at least 10% visible
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const container = entry.target;
                        loadVideoForContainer(container);

                        // Stop observing this container once video is loaded
                        observer.unobserve(container);
                    }
                });
            }, options);

            // Observe all video containers
            const containers = document.querySelectorAll('.video-container');
            containers.forEach(container => {
                observer.observe(container);
            });

            // Pre-load the first few videos immediately for better UX
            const preloadCount = Math.min(4, containers.length);
            for (let i = 0; i < preloadCount; i++) {
                loadVideoForContainer(containers[i]);
            }
        }

        // Open preview modal
        function openPreview(animation) {
            const modal = document.getElementById('preview-modal');

            // Set title and meta
            document.getElementById('preview-title').textContent = animation.title;

            const previewMeta = document.getElementById('preview-meta');
            previewMeta.innerHTML = '';

            // Add product info
            if (animation.product) {
                const productInfo = document.createElement('div');
                productInfo.style.display = 'flex';
                productInfo.style.alignItems = 'center';
                productInfo.style.marginBottom = '12px';

                if (animation.product_logo) {
                    const logoImg = document.createElement('img');
                    logoImg.src = animation.product_logo;
                    logoImg.style.height = '24px';
                    logoImg.style.marginRight = '8px';
                    productInfo.appendChild(logoImg);
                }

                const productName = document.createElement('span');
                productName.textContent = animation.product;
                productName.style.color = '#ff5f1f';
                productName.style.fontWeight = '500';
                productInfo.appendChild(productName);

                previewMeta.appendChild(productInfo);
            }

            // Add platform tag
            if (animation.platform) {
                const platformTag = document.createElement('span');
                platformTag.className = 'meta-tag';
                platformTag.textContent = animation.platform;
                previewMeta.appendChild(platformTag);
            }

            // Add interaction tag(s)
            if (animation.interaction) {
                const interactions = Array.isArray(animation.interaction) ?
                    animation.interaction : [animation.interaction];

                interactions.forEach(interaction => {
                    if (!interaction) return;

                    const interactionTag = document.createElement('span');
                    interactionTag.className = 'meta-tag';
                    interactionTag.textContent = interaction;
                    previewMeta.appendChild(interactionTag);
                });
            }

            // Set video
            const videoWrapper = modal.querySelector('.video-wrapper');
            videoWrapper.innerHTML = '';

            const video = document.createElement('video');
            video.style.width = '100%';
            video.style.height = 'auto';
            video.style.maxHeight = '350px';
            video.style.objectFit = 'contain';
            video.controls = true;
            video.muted = true;
            video.autoplay = true;
            video.loop = true;
            video.playsInline = true;
            video.src = animation.video_url;

            videoWrapper.appendChild(video);

            // Set add button action
            document.getElementById('preview-add').onclick = () => {
                addToFigma(animation);
                closePreview();
            };

            // Set close button action
            document.getElementById('preview-close').onclick = closePreview;

            // Add click outside to close
            modal.onclick = (e) => {
                if (e.target === modal) {
                    closePreview();
                }
            };

            // Show modal
            modal.style.display = 'flex';

            // Play video
            video.play().catch(err => console.warn("Preview video autoplay failed:", err));
        }

        // Close preview modal
        function closePreview() {
            const modal = document.getElementById('preview-modal');

            // Stop any videos
            const videos = modal.querySelectorAll('video');
            videos.forEach(video => {
                try {
                    video.pause();
                } catch (e) {
                    console.error("Error stopping video:", e);
                }
            });

            // Hide modal
            modal.style.display = 'none';
        }

        // Add to Figma
        function addToFigma(animation) {
            console.log("Adding to Figma:", animation);

            // Create a clean copy of the animation with consistent properties
            const cleanAnimation = {
                id: animation.id,
                title: animation.title,
                platform: animation.platform || 'Web App',
                interaction: Array.isArray(animation.interaction) ?
                    animation.interaction[0] : animation.interaction,
                description: animation.description || `${animation.title} animation`,
                url: animation.url || '',
                video_url: animation.video_url,
                product: animation.product || 'Ripplix',
                industry: animation.industry || '',
                product_logo: animation.product_logo || ''
            };

            // Send message to plugin code
            parent.postMessage({
                pluginMessage: {
                    type: 'add-animation',
                    animation: cleanAnimation
                }
            }, '*');
        }

        // Set up event handlers
        function setupEventHandlers() {
            // Set up search
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                searchInput.addEventListener('input', handleSearch);
            }

            // Set up platform dropdown
            const platformSelect = document.getElementById('platform-select');
            if (platformSelect) {
                platformSelect.addEventListener('change', () => {
                    // Clear previous platform filter
                    activeFilters.platform = platformSelect.value || null;

                    // Apply filters
                    applyFilters();
                });
            }

            // Set up close button
            const closeBtn = document.getElementById('close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    parent.postMessage({
                        pluginMessage: {
                            type: 'cancel'
                        }
                    }, '*');
                });
            }

            // Set up filter tags
            const filterTags = document.querySelectorAll('.filter-tag');
            filterTags.forEach(tag => {
                // Add click handler
                tag.addEventListener('click', () => {
                    const filterType = tag.getAttribute('data-filter');
                    const filterValue = tag.getAttribute('data-value');

                    // Toggle filter
                    if (activeFilters[filterType] === filterValue) {
                        // If already active, clear filter
                        activeFilters[filterType] = null;

                        // Reset style
                        tag.classList.remove('active');
                    } else {
                        // Clear other filters of same type
                        document.querySelectorAll(`.filter-tag[data-filter="${filterType}"]`).forEach(t => {
                            t.classList.remove('active');
                        });

                        // Set new filter
                        activeFilters[filterType] = filterValue;

                        // Update style
                        tag.classList.add('active');
                    }

                    // Apply filters
                    applyFilters();
                });
            });

            // Add ESC key handler
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closePreview();
                }
            });

            // Setup message handler for plugin communication
            window.onmessage = (event) => {
                const message = event.data.pluginMessage;
                if (!message) return;

                // Handle different message types
                if (message.type === 'fetch-svg') {
                    // This is a new message type for fetching SVG data
                    fetchSvgAndSendToPlugin(message.url, message.animationData, message.nodeId);
                } else if (message.type === 'fetch-svg-for-plugin') {
                    // Alternative method for fetching SVG through the UI
                    fetchSvgAndSendToPlugin(message.url, message.animationData, message.nodeId);
                } else if (message.type === 'show-copy-message') {
                    // Display copy URL message
                    console.log('URL to copy:', message.url);

                    // Show copy dialog or handle as needed

                    // Send confirmation back to plugin
                    parent.postMessage({
                        pluginMessage: {
                            type: 'copy-confirmed'
                        }
                    }, '*');
                } else if (message.type === 'copy-to-clipboard') {
                    // Copy text to clipboard
                    try {
                        navigator.clipboard.writeText(message.text)
                            .then(() => console.log('Text copied to clipboard'))
                            .catch(err => console.error('Failed to copy:', err));
                    } catch (err) {
                        console.error('Clipboard API error:', err);
                    }
                } else if (message.type === 'animation-added') {
                    // Animation has been added to Figma
                    if (message.success) {
                        console.log('Animation added successfully:', message.message);
                        // Update the animation counter
                        const countEl = document.getElementById('animation-count');
                        if (countEl) {
                            const currentCount = parseInt(countEl.textContent || '0');
                            countEl.textContent = (currentCount + 1).toString();
                        }
                    } else {
                        console.error('Error adding animation:', message.error);
                    }
                }
            };
        }

        // Apply all filters and search
        function applyFilters() {
            // Reset pagination state
            paginationState.currentPage = 1;

            // Get the grid
            const grid = document.getElementById('animation-grid');
            if (!grid) return;

            // Clear the grid
            grid.innerHTML = '';

            // Add the first page of filtered animations
            const visibleAnimations = getVisibleAnimations();

            // Show the first page of filtered animations
            visibleAnimations.forEach(animation => {
                const card = createAnimationCard(animation);
                grid.appendChild(card);
            });

            // Initialize lazy loading for the new cards
            initLazyLoading();

            // Check if we need to show "no results" message
            if (visibleAnimations.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'loading';
                noResults.textContent = 'No animations found matching your filters.';
                grid.appendChild(noResults);
            }
        }

        // Handle search
        function handleSearch() {
            applyFilters();
        }

        // Update interaction filters with API data
        function updateInteractionFilters(interactions) {
            const filterContainer = document.getElementById('filter-container');
            if (!filterContainer) return;

            // Clear existing filters except for platform filters
            const platformFilters = document.querySelectorAll('.filter-button[data-type="platform"]');
            filterContainer.innerHTML = '';

            // Add platform filters back
            platformFilters.forEach(filter => {
                filterContainer.appendChild(filter.cloneNode(true));
            });

            // Add interaction filters
            interactions.forEach(interaction => {
                if (!interaction) return;

                const button = document.createElement('button');
                button.className = 'filter-button';
                button.dataset.type = 'interaction';
                button.dataset.value = interaction;
                button.textContent = interaction;
                button.onclick = toggleFilter;

                filterContainer.appendChild(button);
            });

            // Re-attach click handlers
            document.querySelectorAll('.filter-button').forEach(button => {
                button.onclick = toggleFilter;
            });
        }

        // Helper function to check if a URL is valid
        function isValidUrl(string) {
            try {
                // Check if string is empty or just whitespace
                if (!string || string.trim() === '') {
                    return false;
                }

                // Check if it's a relative URL starting with /
                if (string.startsWith('/')) {
                    return true;
                }

                // Check using URL constructor
                const url = new URL(string);
                return url.protocol === 'http:' || url.protocol === 'https:' || url.protocol === 'data:';
            } catch (_) {
                return false;
            }
        }

        // Function to fetch SVG data and send it back to the plugin
        async function fetchSvgAndSendToPlugin(url, animationData, nodeId) {
            try {
                console.log('Fetching SVG from:', url);

                // Fetch the SVG text
                const response = await fetch(url);

                if (!response.ok) {
                    throw new Error(`Failed to fetch SVG: ${response.status} ${response.statusText}`);
                }

                // Get the SVG as text
                const svgText = await response.text();

                // Convert SVG text to bytes using TextEncoder
                const encoder = new TextEncoder();
                const svgBytes = encoder.encode(svgText);

                // Convert to array for transmission
                const bytesArray = Array.from(svgBytes);

                // Send the SVG data back to the plugin
                parent.postMessage({
                    pluginMessage: {
                        type: 'svg-data',
                        svgData: bytesArray,
                        animation: animationData,
                        nodeId: nodeId
                    }
                }, '*');

                console.log('SVG data sent to plugin');
            } catch (error) {
                console.error('Error fetching SVG:', error);

                // Notify the plugin of the failure
                parent.postMessage({
                    pluginMessage: {
                        type: 'svg-fetch-failed',
                        error: error instanceof Error ? error.message : 'Unknown error',
                        animation: animationData
                    }
                }, '*');
            }
        }
    </script>
</body>

</html>