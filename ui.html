<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ripplix - UI Animation Library</title>
    <link rel="icon" href="https://www.ripplix.com/wp-content/uploads/2024/12/Logo-of-Ripplix-Retina.svg" type="image/svg+xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* CSS Variables */
        
         :root {
            --background-color: white;
            --card-background: white;
            --text-color: #333;
            --light-text: #777;
            --border-color: #e0e0e0;
            --primary-color: #2962ff;
            --primary-dark: #0039cb;
            --hover-color: #f5f5f5;
            --tag-background: #f0f0f0;
            --tag-text: #555;
            --modal-background: rgba(0, 0, 0, 0.7);
            --error-color: #d32f2f;
            --success-color: #43a047;
            --error-background: #ffebee;
            /* New loading screen colors */
            --loading-bg: #100F19;
            --loading-accent: #694EE4;
            --loading-secondary: #1F1C37;
            --primary-color: #1A66E5;
            --secondary-color: #3B82F6;
            --background-color: #F8F8F9;
            --card-background: #FFFFFF;
            --text-color: #333333;
            --light-text: #666666;
            --border-color: #E5E7EB;
            --hover-color: #F3F4F6;
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            --card-radius: 8px;
            --transition-speed: 0.2s;
            --dropdown-hover-bg: #F2EDFF;
            --dropdown-hover-text: #3F2B87;
        }
        /* Modern fullscreen loading overlay */
        
        .fullscreen-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--loading-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10000;
            font-family: 'Poppins', sans-serif;
            opacity: 1;
            transition: opacity 0.6s ease;
        }
        
        .fullscreen-loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-logo {
            width: 80px;
            height: 80px;
            margin-bottom: 40px;
        }
        
        .loading-message {
            max-width: 500px;
            text-align: center;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 30px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.9);
            padding: 0 20px;
        }
        
        .loading-spinner {
            position: relative;
            width: 50px;
            height: 50px;
        }
        
        .loading-spinner:before {
            content: '';
            box-sizing: border-box;
            position: absolute;
            top: 0;
            left: 0;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--loading-accent);
            animation: spinner 1s linear infinite;
        }
        
        @keyframes spinner {
            to {
                transform: rotate(360deg);
            }
        }
        
        .loading-dots-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 40px;
        }
        
        .loading-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--loading-accent);
            animation: pulse 1.5s ease-in-out infinite;
            opacity: 0.2;
        }
        
        .loading-dot:nth-child(2) {
            animation-delay: 0.2s;
            opacity: 0.4;
        }
        
        .loading-dot:nth-child(3) {
            animation-delay: 0.4s;
            opacity: 0.6;
        }
        
        .loading-dot:nth-child(4) {
            animation-delay: 0.6s;
            opacity: 0.8;
        }
        
        .loading-dot:nth-child(5) {
            animation-delay: 0.8s;
            opacity: 1;
        }
        
        @keyframes pulse {
            0%,
            100% {
                transform: scale(0.8);
                opacity: 0.3;
            }
            50% {
                transform: scale(1);
                opacity: 1;
            }
        }
        /* Global styles */
        
         :root {
            --primary-color: #1A66E5;
            --secondary-color: #3B82F6;
            --background-color: #F8F8F9;
            --card-background: #FFFFFF;
            --text-color: #333333;
            --light-text: #666666;
            --border-color: #E5E7EB;
            --hover-color: #F3F4F6;
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            --card-radius: 8px;
            --transition-speed: 0.2s;
        }
        
        * {
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }
        
        body {
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            font-size: 14px;
            line-height: 1.5;
            overflow-x: hidden;
        }
        /* Header styles */
        
        .header {
            background-color: #F8F8F9;
            padding: 16px;
            border-bottom: none;
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .brand {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .logo-container {
            display: flex;
            align-items: center;
            margin-right: 1rem;
        }
        
        .logo {
            height: 24px;
            width: auto;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        
        .logo:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
        }
        
        .logo:active {
            transform: scale(0.95);
        }
        
        .stats {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .ref-count {
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
            font-size: 13px;
            color: #170B44;
        }
        
        .sparkle-icon {
            font-size: 14px;
            margin-right: 2px;
        }
        
        .support-btn {
            padding: 8px 12px 8px 12px;
            border-radius: 8px;
            background-color: #F2EDFF;
            border: none;
            font-size: 13px;
            font-weight: 600;
            color: #3F2B87;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .support-btn:hover {
            background-color: #e5e7eb;
        }
        
        .close-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            background-color: transparent;
            border: none;
            font-size: 16px;
            color: var(--light-text);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .close-btn:hover {
            background-color: #f5f5f7;
        }
        
        .title {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }
        
        .subtitle {
            font-size: 12px;
            color: var(--light-text);
            margin: 0;
        }
        /* Count badge styles */
        
        .animation-count-container {
            background-color: #f0f0f0;
            padding: 3px 8px;
            border-radius: 100px;
            font-size: 12px;
            color: var(--light-text);
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
        }
        
        .total-count {
            font-weight: 600;
            color: var(--text-color);
        }
        
        .filtered-count {
            font-size: 11px;
            color: var(--light-text);
        }
        /* Search and filter bar */
        
        .search-and-filters {
            padding: 0 16px 16px;
            background-color: #F8F8F9;
            border-top: none;
            position: sticky;
            top: 64px;
            /* Below the header */
            z-index: 9;
            transition: transform 0.3s ease;
        }
        
        .search-row {
            display: flex;
            margin-bottom: 16px;
            gap: 16px;
        }
        
        .search-label {
            font-size: 14px;
            font-weight: 500;
            color: #828791;
            margin-bottom: 8px;
        }
        
        .platform-label {
            font-size: 14px;
            font-weight: 500;
            color: #828791;
            margin-bottom: 8px;
        }
        
        .search-container {
            margin-bottom: 0;
            position: relative;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        
        .search-input-container {
            display: flex;
            position: relative;
            width: 100%;
        }
        
        .search-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 8px 0 0 8px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: #ffffff;
        }
        
        .search-button {
            background-color: #14114B;
            color: white;
            border: none;
            border-radius: 0 8px 8px 0;
            width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        .search-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .platform-dropdown {
            position: relative;
            min-width: 160px;
        }
        
        .platform-select {
            width: 100%;
            padding: 10px 12px;
            padding-right: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            background-color: #FCFCFC;
            appearance: none;
            cursor: pointer;
            color: #333;
        }
        /* Styling for dropdown options */
        
        .platform-select option:hover,
        .platform-select option:focus {
            background-color: var(--dropdown-hover-bg) !important;
            color: var(--dropdown-hover-text) !important;
        }
        /* Remove selection highlight */
        
        .platform-select option:checked {
            background-color: transparent !important;
            color: inherit !important;
        }
        /* When hovering on a checked option, still show the hover color */
        
        .platform-select option:checked:hover {
            background-color: var(--dropdown-hover-bg) !important;
            color: var(--dropdown-hover-text) !important;
        }
        
        .dropdown-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: #555;
            margin-top: 9px;
            /* Adjust to align with the select field */
        }
        
        .filters {
            display: flex;
            flex-wrap: nowrap;
            gap: 12px;
            overflow-x: auto;
            /* Changed back to auto to enable scrolling */
            -ms-overflow-style: none;
            /* Hide scrollbar in IE/Edge */
            scrollbar-width: none;
            /* Hide scrollbar in Firefox */
            padding: 8px 0;
            width: 100%;
            position: relative;
            scroll-behavior: smooth;
        }
        /* Hide scrollbar in WebKit browsers */
        
        .filters::-webkit-scrollbar {
            display: none;
        }
        /* Remove scrollbar styling since it's now hidden */
        /* Add buttons for horizontal scrolling */
        
        .filter-scroll-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background-color: white;
            border: 1px solid #E5E7EB;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
            font-size: 18px;
            transition: all 0.2s;
        }
        
        .filter-scroll-button:hover {
            background-color: #F2EDFF;
            color: #3F2B87;
        }
        
        .filter-scroll-left {
            left: 0;
        }
        
        .filter-scroll-right {
            right: 0;
        }
        /* Remove the fade indicator since we now have buttons */
        
        .filters::after {
            display: none;
        }
        /* Filter container to hold both the buttons and filters */
        
        .filters-container {
            position: relative;
            width: 100%;
            padding: 0 30px;
            /* Add padding to make room for buttons */
        }
        
        .filter-tag {
            padding: 8px 16px;
            background-color: #F8F8F9;
            border: 1px solid #F8F8F9;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: #333;
            white-space: nowrap;
            /* Prevent wrapping of text */
            flex: 0 0 auto;
            /* Don't allow the tags to grow or shrink */
        }
        
        .filter-tag:hover {
            background-color: #FFFFFF !important;
            color: #FFFFFF;
            border-color: #EBEBEB !important;
            border-radius: 10px;
        }
        
        .filter-tag.active {
            background-color: #FFFFFF !important;
            /* Darker purple for active state */
            /* color: white; */
            /* White text for better contrast */
            border-color: #EBEBEB !important;
            border-radius: 10px;
            /* box-shadow: 0 2px 4px rgba(63, 43, 135, 0.2); */
            /* Light shadow for depth */
        }
        
        .animation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 16px;
            padding: 16px;
        }
        
        .animation-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100%;
            padding-top: 12px;
            padding-left: 12px;
            padding-right: 12px;
        }
        
        .animation-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }
        
        .video-container {
            position: relative;
            height: 0;
            padding-bottom: 75%;
            /* 1:1 aspect ratio */
            overflow: hidden;
            background-color: #f5f5f5;
            border-radius: 12px;
        }
        
        .animation-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .product-section {
            display: flex;
            align-items: center;
            padding: 12px 16px 8px;
            gap: 8px;
        }
        
        .product-logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
        }
        
        .product-logo {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 20px;
        }
        
        .product-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .interaction-container {
            display: flex;
            flex-wrap: wrap;
            padding: 0 16px 12px;
            gap: 6px;
        }
        
        .interaction-tag {
            display: inline-block;
            padding: 4px 8px;
            background-color: var(--tag-background);
            color: var(--tag-text);
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .add-button {
            margin: 0 16px 16px;
            padding: 8px 0;
            background-color: #170B44;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .add-button:hover {
            /* Keep the original color */
        }
        
        .loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-color);
            font-size: 14px;
        }
        
        .play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .play-overlay.show-play {
            opacity: 1;
        }
        
        .play-icon {
            width: 48px;
            height: 48px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
            font-size: 16px;
            color: #666;
        }
        
        @media (max-width: 768px) {
            .filter-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .filter-label {
                width: 100%;
                margin-bottom: 4px;
            }
        }
        
        .api-error-message {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 32px;
            margin: 32px auto;
            max-width: 480px;
            text-align: center;
            border-radius: 8px;
            background-color: #FFEBEE;
            border: 1px solid #FFCDD2;
        }
        
        .error-icon {
            margin-bottom: 16px;
        }
        
        .api-error-message h3 {
            color: #D32F2F;
            margin: 0 0 12px 0;
            font-size: 20px;
        }
        
        .api-error-message p {
            margin: 0 0 8px 0;
            color: #424242;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .support-message {
            margin-top: 16px !important;
            font-weight: 500;
        }
        /* Lazy loading for videos */
        
        @media (prefers-reduced-motion: no-preference) {
            .lazy-video {
                opacity: 0;
                transition: opacity 0.5s;
            }
            .lazy-video.loaded {
                opacity: 1;
            }
        }
        
        @media (prefers-reduced-motion: reduce) {
            .animation-card:hover {
                transform: none;
            }
        }
        /* Error styling */
        
        .error-container {
            padding: 20px;
            text-align: center;
            color: var(--text-color);
            background-color: var(--error-background);
            border-radius: 8px;
            margin: 20px auto;
            max-width: 90%;
        }
        
        .retry-button {
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 15px;
        }
        
        .retry-button:hover {
            background-color: var(--primary-dark);
        }
        /* Loading indicator styles */
        
        .loading-more {
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
            margin: 20px auto;
            flex-direction: column;
            transition: opacity 0.3s ease;
            opacity: 0;
            position: relative;
            height: 80px;
        }
        
        .loading-more.visible {
            display: flex;
            opacity: 1;
        }
        
        .loading-dots {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .loading-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--primary-color);
            opacity: 0.6;
            animation: pulse 1.4s ease-in-out infinite;
        }
        
        .loading-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .loading-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes pulse {
            0%,
            100% {
                opacity: 0.6;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }
        
        .loading-text {
            font-size: 14px;
            color: var(--light-text);
            margin-top: 4px;
        }
        /* Browser-specific styles for options */
        /* WebKit browsers */
        
        @media screen and (-webkit-min-device-pixel-ratio:0) {
            .platform-select option:hover {
                background-color: var(--dropdown-hover-bg) !important;
                color: var(--dropdown-hover-text) !important;
            }
        }
        /* Firefox */
        
        @-moz-document url-prefix() {
            .platform-select option:hover,
            .platform-select option:focus,
            .platform-select option:checked {
                background-color: var(--dropdown-hover-bg) !important;
                color: var(--dropdown-hover-text) !important;
                box-shadow: 0 0 10px 100px var(--dropdown-hover-bg) inset !important;
            }
        }
    </style>
</head>

<body>
    <div class="fullscreen-loading" id="fullscreen-loading">
        <div class="loading-logo">
            <svg width="80" height="80" viewBox="0 0 50 50" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M25 5C13.9543 5 5 13.9543 5 25C5 36.0457 13.9543 45 25 45C36.0457 45 45 36.0457 45 25C45 13.9543 36.0457 5 25 5Z" stroke="#694EE4" stroke-width="2.5" stroke-linecap="round" stroke-dasharray="1 6"/>
                <path d="M25 15V25L32 32" stroke="#694EE4" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
        <div class="loading-dots-container">
            <div class="loading-dot"></div>
            <div class="loading-dot"></div>
            <div class="loading-dot"></div>
            <div class="loading-dot"></div>
            <div class="loading-dot"></div>
        </div>
        <p class="loading-message">Loading a curated library of UI Animation, Micro Interaction, Interaction Flow to make your product more delightful.</p>
    </div>

    <div class="header">
        <div class="logo-container">
            <img src="https://www.ripplix.com/wp-content/uploads/2024/12/Logo-of-Ripplix-Retina.svg" alt="Ripplix" class="logo">
        </div>
        <div class="stats">
            <div class="ref-count">
                <span class="sparkle-icon">🎉</span>
                <span id="animation-count">0</span>
                <span id="count-label">Animations</span>
                <span id="original-count" class="original-count" style="font-size: 12px; color: #666; display: none;">(of 1253 total)</span>
            </div>
            <a href="https://buymeacoffee.com/hasanbashar" target="_blank" rel="noopener noreferrer">
                <button class="support-btn">Support Us</button>
            </a>

        </div>
    </div>

    <div class="search-and-filters">
        <div class="search-row">
            <div class="search-container">
                <div class="search-label">Search for inspirations</div>
                <div class="search-input-container">
                    <input type="text" id="search-input" class="search-input" placeholder="Hover effect, loading">
                    <button type="button" class="search-button">
                        <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                        </svg>
                    </button>
                </div>
            </div>

            <div class="platform-dropdown">
                <div class="platform-label">Platform</div>
                <select id="platform-select" class="platform-select">
                    <option value="">All</option>
                    <option value="Web App">Web App</option>
                    <option value="Mobile App">Mobile App</option>
                    <option value="Wearables">Wearables</option>
                    <option value="Website">Website</option>
                    <option value="XR / AR / VR">XR / AR / VR</option>
                </select>
                <div class="dropdown-icon">▼</div>
            </div>
        </div>

        <div class="filters-container">
            <button class="filter-scroll-button filter-scroll-left" id="scroll-left">
                &#8249;
            </button>
            <div class="filters" id="filter-container">
                <span class="filter-tag" data-filter="interaction" data-value="Hover">Hover</span>
                <span class="filter-tag" data-filter="interaction" data-value="Drop down">Drop down</span>
                <span class="filter-tag" data-filter="interaction" data-value="Popup">Popup</span>
                <span class="filter-tag" data-filter="interaction" data-value="Loading">Loading</span>
                <span class="filter-tag" data-filter="interaction" data-value="Tooltip">Tooltip</span>
                <span class="filter-tag" data-filter="interaction" data-value="Toggle">Toggle</span>
            </div>
            <button class="filter-scroll-button filter-scroll-right" id="scroll-right">
                &#8250;
            </button>
        </div>
    </div>

    <div id="loading-indicator" class="loading">Loading animations from Ripplix API...</div>
    <div id="animations-container">
        <!-- This will be populated with animations -->
    </div>

    <div id="preview-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.7); z-index: 100; justify-content: center; align-items: center;">
        <div style="background-color: white; border-radius: 8px; width: 80%; max-width: 600px; overflow: visible; position: relative;">
            <button id="preview-close" style="position: absolute; top: 12px; right: 12px; background: transparent; border: none; font-size: 20px; cursor: pointer;">✕</button>
            <div style="padding: 16px; border-bottom: 1px solid #e0e0e0;">
                <h2 id="preview-title" style="margin: 0 0 8px 0; color: #14114B;"></h2>
                <div id="preview-meta" style="display: flex; gap: 8px;"></div>
            </div>
            <div class="video-wrapper" style="padding: 16px;"></div>
            <div style="padding: 16px; border-top: 1px solid #e0e0e0;">
                <button id="preview-add" style="background-color: #14114B; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Add to Figma</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let allAnimations = []; // Store all animations
        let animationsData = []; // For filtering
        let activeFilters = {
            platform: null,
            interaction: null
        };
        let paginationState = {
            itemsPerPage: 12,
            currentPage: 1,
            isLoading: false,
            hasMoreItems: true,
            totalItems: 0,
            apiPage: 1
        };

        // Create a minimal set of fallback animations
        const fallbackData = {
            animations: [{
                id: "fallback1",
                title: "Button Hover Animation",
                url: "https://www.ripplix.com/library/hover-animation/",
                video_url: "https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/5dccb40eb29640f1d718305b9029d4ea/downloads/default.mp4",
                product: "Ripplix",
                product_logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg",
                platform: "Website",
                industry: "UI/UX",
                interaction: ["Hover"],
                logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg"
            }, {
                id: "fallback2",
                title: "Loading Animation",
                url: "https://www.ripplix.com/library/loading-animation/",
                video_url: "https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/e5d0189359b7e61415ddc2736977c190/downloads/default.mp4",
                product: "Ripplix",
                product_logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg",
                platform: "Web App",
                industry: "UI/UX",
                interaction: ["Loading"],
                logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg"
            }, {
                id: "fallback3",
                title: "Dropdown Menu",
                url: "https://www.ripplix.com/library/dropdown-menu/",
                video_url: "https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/8e36c8c0878a1fb01e910f81d1dd0a35/downloads/default.mp4",
                product: "Ripplix",
                product_logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg",
                platform: "Web App",
                industry: "UI/UX",
                interaction: ["Dropdown"],
                logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg"
            }, {
                id: "fallback4",
                title: "Toggle Switch Animation",
                url: "https://www.ripplix.com/library/toggle-switch/",
                video_url: "https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/9a75c9fec2624d8815ed353e0184eb8b/downloads/default.mp4",
                product: "Ripplix",
                product_logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg",
                platform: "Web App",
                industry: "UI/UX",
                interaction: ["Toggle"],
                logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg"
            }, {
                id: "fallback5",
                title: "Scroll Animation",
                url: "https://www.ripplix.com/library/scroll-animation/",
                video_url: "https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/5b87c9fec2624d8815ed353e0184eb8b/downloads/default.mp4",
                product: "Ripplix",
                product_logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg",
                platform: "Website",
                industry: "UI/UX",
                interaction: ["Scroll"],
                logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg"
            }, {
                id: "fallback6",
                title: "Modal Dialog Animation",
                url: "https://www.ripplix.com/library/modal-dialog/",
                video_url: "https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/7b99c9fec2624d8815ed353e0184eb8b/downloads/default.mp4",
                product: "Ripplix",
                product_logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg",
                platform: "Web App",
                industry: "UI/UX",
                interaction: ["Modal"],
                logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg"
            }, {
                id: "fallback7",
                title: "Card Hover Effect",
                url: "https://www.ripplix.com/library/card-hover/",
                video_url: "https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/6c87c9fec2624d8815ed353e0184eb8b/downloads/default.mp4",
                product: "Ripplix",
                product_logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg",
                platform: "Website",
                industry: "UI/UX",
                interaction: ["Hover"],
                logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg"
            }, {
                id: "fallback8",
                title: "Tab Switching Animation",
                url: "https://www.ripplix.com/library/tab-switching/",
                video_url: "https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/3e87c9fec2624d8815ed353e0184eb8b/downloads/default.mp4",
                product: "Ripplix",
                product_logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg",
                platform: "Web App",
                industry: "UI/UX",
                interaction: ["Tabs"],
                logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg"
            }, {
                id: "fallback9",
                title: "Page Transition",
                url: "https://www.ripplix.com/library/page-transition/",
                video_url: "https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/2d87c9fec2624d8815ed353e0184eb8b/downloads/default.mp4",
                product: "Ripplix",
                product_logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg",
                platform: "Website",
                industry: "UI/UX",
                interaction: ["Transition"],
                logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg"
            }, {
                id: "fallback10",
                title: "Button Click Animation",
                url: "https://www.ripplix.com/library/button-click/",
                video_url: "https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/1c87c9fec2624d8815ed353e0184eb8b/downloads/default.mp4",
                product: "Ripplix",
                product_logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg",
                platform: "Web App",
                industry: "UI/UX",
                interaction: ["Button"],
                logo: "https://www.ripplix.com/wp-content/uploads/2024/04/Logo-figma.svg"
            }]
        };

        // DOM ready handler
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM loaded, initializing plugin");

            // Show main loading screen
            showLoadingScreen();

            // Initialize animation count to a loading state
            const countElement = document.getElementById('animation-count');
            const countLabel = document.getElementById('count-label');
            if (countElement && countLabel) {
                countElement.textContent = "Loading";
                countLabel.textContent = "Ref...";
            } else {
                console.warn("animation-count or count-label element not found");
            }

            // Make sure the main structure exists
            let mainContent = document.querySelector('.main-content');
            if (!mainContent) {
                console.log("Creating main content container");
                mainContent = document.createElement('div');
                mainContent.className = 'main-content';
                document.body.appendChild(mainContent);
            }

            // Make sure animations container exists
            let container = document.getElementById('animations-container');
            if (!container) {
                console.log("Creating animations container");
                container = document.createElement('div');
                container.id = 'animations-container';
                mainContent.appendChild(container);
            }

            if (!document.getElementById('animation-grid')) {
                console.log("Creating animation grid container");
                const grid = document.createElement('div');
                grid.id = 'animation-grid';
                grid.className = 'animation-grid';
                container.appendChild(grid);
            }

            // Attach event listeners to any initial filter tags
            setupFilterTagEventListeners();

            // Setup filter scroll buttons
            setupFilterScrollButtons();

            // Add a slight delay to ensure DOM is fully ready
            setTimeout(() => {
                // Load initial animations (12 items) with pagination support
                loadAnimations();

                // Set up event handlers
                setupEventHandlers();
            }, 100);
        });

        // Show fullscreen loading overlay
        function showLoadingScreen() {
            const loadingScreen = document.getElementById('fullscreen-loading');
            if (loadingScreen) {
                // Update loading text to be modern and clean
                const loadingText = loadingScreen.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = 'Loading UI Animations';
                }

                // Clear any error messages or attempt indicators that might be visible
                const errorElements = loadingScreen.querySelectorAll('.error-message, .attempt-indicator');
                errorElements.forEach(element => {
                    element.remove();
                });

                loadingScreen.classList.remove('hidden');
                document.body.style.overflow = 'hidden'; // Prevent scrolling while loading
            }

            // Hide default loading indicator
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }

            // Remove any error containers from previous attempts
            const errorContainers = document.querySelectorAll('.error-container');
            errorContainers.forEach(container => {
                container.style.display = 'none';
            });
        }

        // Hide fullscreen loading overlay
        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('fullscreen-loading');
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');

                // Allow scrolling after a delay to ensure animation completes
                setTimeout(() => {
                    document.body.style.overflow = '';
                }, 600);
            }
        }

        // Fetch animations from API
        async function fetchAnimationsFromApi() {
            console.log("Fetching animations from API");

            // Show main loading screen
            showLoadingScreen();

            // Try multiple API endpoints with different configurations
            const apiEndpoints = [
                // Main API endpoints
                'https://www.ripplix.com/wp-json/ripplix/v1/animations/',
                'https://ripplix.com/wp-json/ripplix/v1/animations/',
                // Main API endpoints with pagination
                'https://www.ripplix.com/wp-json/ripplix/v1/animations/?per_page=1500',
                'https://ripplix.com/wp-json/ripplix/v1/animations/?per_page=1500',
                // Direct URLs to JSON files (for CORS fallback)
                'https://cdn.ripplix.com/animations/all.json',
                'https://static.ripplix.com/api/animations.json'
            ];

            // Log the start of API fetch
            console.log(`Attempting to fetch from ${apiEndpoints.length} possible endpoints`);

            let successfulFetch = false;
            let finalData = null;
            let finalError = null;

            // Try each endpoint with multiple fetch approaches
            for (let i = 0; i < apiEndpoints.length; i++) {
                const apiUrl = apiEndpoints[i];
                console.log(`Trying endpoint ${i+1}: ${apiUrl}`);

                // Try different fetch approaches for each endpoint
                const fetchApproaches = [
                    // Approach 1: Full options with CORS
                    {
                        method: 'GET',
                        mode: 'cors',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache'
                        },
                        credentials: 'omit'
                    },
                    // Approach 2: Simpler fetch with no CORS
                    {
                        method: 'GET',
                        mode: 'no-cors'
                    },
                    // Approach 3: Minimal fetch with default options
                    {}
                ];

                // Try each fetch approach for the current endpoint
                for (let j = 0; j < fetchApproaches.length; j++) {
                    const fetchOptions = fetchApproaches[j];
                    console.log(`Trying fetch approach ${j+1} for ${apiUrl}`);

                    // Set up request timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

                    try {
                        // Add the signal to the fetch options
                        const options = {...fetchOptions,
                            signal: controller.signal
                        };

                        // Fetch from the API
                        console.log(`Making API request to ${apiUrl} with options:`, options);
                        const response = await fetch(apiUrl, options);

                        clearTimeout(timeoutId);

                        console.log(`API response status from ${apiUrl}:`, response.status);

                        if (!response.ok) {
                            console.error(`Endpoint ${apiUrl} failed with status: ${response.status}`);
                            continue; // Try next fetch approach
                        }

                        // Get the response data
                        const responseText = await response.text();
                        console.log(`API response length from ${apiUrl}: ${responseText.length} characters`);

                        if (!responseText || responseText.length < 50) {
                            console.error(`Response from ${apiUrl} is too short or empty`);
                            continue; // Try next fetch approach
                        }

                        // Parse the response
                        let data;
                        try {
                            data = JSON.parse(responseText);
                            console.log(`Successfully parsed JSON from ${apiUrl}`);
                        } catch (parseError) {
                            console.error(`JSON parse error from ${apiUrl}:`, parseError);
                            console.log(`First 100 chars of response: ${responseText.substring(0, 100)}...`);
                            continue; // Try next fetch approach
                        }

                        // Check if we received any data
                        if (!data) {
                            console.error(`${apiUrl} returned null or undefined data`);
                            continue; // Try next fetch approach
                        }

                        console.log(`Data structure from ${apiUrl}:`, Object.keys(data));

                        // Process different API response formats
                        if (Array.isArray(data)) {
                            // Direct array of animations
                            console.log(`${apiUrl} returned direct array of ${data.length} animations`);
                            if (data.length > 0) {
                                console.log(`First animation:`, data[0]);
                                finalData = {
                                    animations: data
                                };
                                successfulFetch = true;
                                break; // Found working approach
                            }
                        } else if (data.animations && Array.isArray(data.animations)) {
                            // Object with animations array
                            console.log(`${apiUrl} returned object with ${data.animations.length} animations`);
                            if (data.animations.length > 0) {
                                console.log(`First animation:`, data.animations[0]);
                                finalData = data;
                                successfulFetch = true;
                                break; // Found working approach
                            }
                        } else {
                            console.error(`${apiUrl} returned unexpected data structure`);
                            console.log(`Data keys: ${Object.keys(data).join(', ')}`);
                            continue; // Try next fetch approach
                        }
                    } catch (error) {
                        clearTimeout(timeoutId);
                        console.error(`Error fetching from ${apiUrl} with approach ${j+1}:`, error);
                        finalError = error;
                        continue; // Try next fetch approach
                    }
                }

                if (successfulFetch) {
                    break; // Found working endpoint, stop trying others
                }
            }

            // If direct fetching failed, try CORS proxies
            if (!successfulFetch) {
                console.log("Direct API fetching failed, trying CORS proxies");
                const proxyResult = await tryFetchWithCorsProxies();
                if (proxyResult) {
                    successfulFetch = true;
                    finalData = proxyResult;
                }
            }

            // Process results
            if (successfulFetch && finalData) {
                console.log(`Successfully fetched animation data`);
                processApiData(finalData);
            } else {
                console.error("All API endpoints and approaches failed");

                // Use hardcoded fallback data as last resort
                useFallbackData();
            }
        }

        // Try fetching via CORS proxies
        async function tryFetchWithCorsProxies() {
            // List of CORS proxies to try
            const corsProxies = [
                'https://cors-anywhere.herokuapp.com/',
                'https://api.allorigins.win/raw?url=',
                'https://api.codetabs.com/v1/proxy?quest='
            ];

            // Target endpoints to try with proxies
            const targetEndpoints = [
                'https://www.ripplix.com/wp-json/ripplix/v1/animations/',
                'https://ripplix.com/wp-json/ripplix/v1/animations/'
            ];

            // Try each proxy with each target
            for (const proxy of corsProxies) {
                for (const target of targetEndpoints) {
                    const proxyUrl = `${proxy}${encodeURIComponent(target)}`;
                    console.log(`Trying CORS proxy: ${proxyUrl}`);

                    // Set up request timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout

                    try {
                        const response = await fetch(proxyUrl, {
                            method: 'GET',
                            signal: controller.signal,
                            headers: {
                                'Accept': 'application/json',
                                'X-Requested-With': 'XMLHttpRequest'
                            }
                        });

                        clearTimeout(timeoutId);

                        if (!response.ok) {
                            console.error(`Proxy ${proxy} failed with status: ${response.status}`);
                            continue;
                        }

                        const data = await response.json();

                        // Check if the response has the expected format
                        if (data && ((Array.isArray(data) && data.length > 0) ||
                                (data.animations && Array.isArray(data.animations) && data.animations.length > 0))) {
                            console.log(`Successfully fetched via proxy ${proxy}`);
                            return data;
                        }
                    } catch (error) {
                        clearTimeout(timeoutId);
                        console.error(`Error using proxy ${proxy}:`, error);
                    }
                }
            }

            return null; // All proxies failed
        }

        // Use hardcoded fallback data when API fails
        function useFallbackData() {
            console.log("Using fallback animation data");

            // Try to show what went wrong
            const errorContainer = document.createElement('div');
            errorContainer.style.backgroundColor = 'rgba(255, 193, 7, 0.2)';
            errorContainer.style.color = '#856404';
            errorContainer.style.padding = '12px 16px';
            errorContainer.style.margin = '0 16px 16px';
            errorContainer.style.borderRadius = '6px';
            errorContainer.style.fontSize = '14px';
            errorContainer.style.lineHeight = '1.5';
            errorContainer.style.textAlign = 'center';

            // Create header 
            const header = document.createElement('div');
            header.style.fontWeight = 'bold';
            header.style.marginBottom = '8px';
            header.textContent = 'Unable to connect to Ripplix API';
            errorContainer.appendChild(header);

            // Create message
            const message = document.createElement('div');
            message.innerHTML = 'Using limited offline data. The plugin will have reduced functionality.<br>Please check your internet connection and try again later.';
            errorContainer.appendChild(message);

            // Add a retry button
            const retryButton = document.createElement('button');
            retryButton.textContent = 'Retry Connection';
            retryButton.style.marginTop = '10px';
            retryButton.style.padding = '6px 12px';
            retryButton.style.backgroundColor = '#FFC107';
            retryButton.style.color = '#856404';
            retryButton.style.border = 'none';
            retryButton.style.borderRadius = '4px';
            retryButton.style.cursor = 'pointer';
            retryButton.addEventListener('click', () => {
                // Reload the plugin
                window.location.reload();
            });
            errorContainer.appendChild(retryButton);

            // Process the fallback data
            processApiData({
                animations: fallbackData.animations
            });

            // Show message about using fallback data
            const container = document.getElementById('animations-container');
            if (container) {
                // Insert at the top of the container
                if (container.firstChild) {
                    container.insertBefore(errorContainer, container.firstChild);
                } else {
                    container.appendChild(errorContainer);
                }
            }
        }

        // Process API data and create grid
        function processApiData(apiData) {
            // Check if we have valid data
            if (!apiData || (!apiData.animations && !Array.isArray(apiData)) ||
                (apiData.animations && !Array.isArray(apiData.animations)) ||
                (apiData.animations && apiData.animations.length === 0) ||
                (Array.isArray(apiData) && apiData.length === 0)) {
                console.error("API returned invalid or empty data");
                showApiError("No valid animation data could be retrieved from the API");
                return;
            }

            // Handle different API response formats
            let originalAnimations = [];
            if (Array.isArray(apiData)) {
                // Direct array of animations
                originalAnimations = apiData;
                console.log("API returned direct array of animations:", originalAnimations.length);
            } else if (apiData.animations && Array.isArray(apiData.animations)) {
                // Object with animations array
                originalAnimations = apiData.animations;
                console.log("API returned object with animations array:", originalAnimations.length);
            }

            console.log("Processing API data with", originalAnimations.length, "animations");

            // Debug: Check interaction formats in the raw data
            console.log("Interaction format samples:");
            for (let i = 0; i < Math.min(5, originalAnimations.length); i++) {
                console.log(`Animation ${i + 1}:`,
                    originalAnimations[i].id,
                    "Interaction:",
                    originalAnimations[i].interaction,
                    "Type:",
                    typeof originalAnimations[i].interaction,
                    "Is Array:",
                    Array.isArray(originalAnimations[i].interaction));
            }

            // Store the original count for reference
            const originalApiCount = originalAnimations.length;
            console.log("Original animation count from API:", originalApiCount);

            // Filter out animations with missing essential data
            const validAnimations = originalAnimations.filter(animation => {
                return animation && animation.id && animation.title &&
                    (animation.video_url || animation.animation_url);
            });

            console.log(`Valid animations (with ID, title, and URL): ${validAnimations.length}`);

            // Process animations to standardize format
            const processedAnimations = validAnimations.map(animation => {
                // Make sure URL is properly formatted
                let videoUrl = animation.video_url || animation.animation_url || '';
                if (videoUrl && videoUrl.includes('cloudflarestream')) {
                    videoUrl = fixCloudflareUrl(videoUrl);
                }

                // Standardize interactions to always be an array
                let interactions = [];
                if (Array.isArray(animation.interaction)) {
                    interactions = animation.interaction.filter(i => i && typeof i === 'string');
                } else if (typeof animation.interaction === 'string' && animation.interaction) {
                    interactions = [animation.interaction];
                } else if (typeof animation.interaction === 'object' && animation.interaction !== null) {
                    // Handle case where interaction might be an object with properties
                    try {
                        // Try to get values from the object
                        const values = Object.values(animation.interaction);
                        interactions = values.filter(v => v && typeof v === 'string');
                    } catch (e) {
                        console.warn("Error processing interaction object:", e);
                    }
                }

                // Standardize the animation object format
                return {
                    id: animation.id.toString(),
                    title: animation.title || 'Untitled Animation',
                    platform: animation.platform || 'Web App',
                    interaction: interactions,
                    url: animation.url || '',
                    video_url: videoUrl,
                    product: animation.product || 'Ripplix',
                    industry: animation.industry || '',
                    product_logo: animation.product_logo || '',
                    logo: animation.logo || animation.product_logo || ''
                };
            });

            // Remove duplicates
            const uniqueAnimations = removeDuplicateAnimations(processedAnimations);
            console.log(`Unique animations after deduplication: ${uniqueAnimations.length}`);

            // Check if we found any animations
            if (uniqueAnimations.length === 0) {
                console.error("No valid animations found after filtering");
                showApiError("No valid animations were found in the API response. Please try again later.");
                return;
            }

            // Set the global animations array
            allAnimations = uniqueAnimations;
            animationsData = uniqueAnimations;

            console.log(`Final animation count: ${allAnimations.length}`);

            // Create grid with the processed animations
            createAnimationGrid(allAnimations);

            // Update the animation count display
            const countEl = document.getElementById('animation-count');
            if (countEl) {
                // Show the total count of unique animations
                countEl.textContent = allAnimations.length.toString();

                // Add a tooltip with more details
                countEl.title = `${allAnimations.length} animations after filtering (API returned ${originalApiCount} total)`;

                // Log the comparison
                console.log(`Displaying ${allAnimations.length} animations out of ${originalApiCount} from the API`);

                // Update the original count display if it exists
                const originalCountEl = document.getElementById('original-count');
                if (originalCountEl) {
                    originalCountEl.textContent = `(of ${originalApiCount} total)`;
                }
            }

            // Set up filter UI with API data
            setupFilters(allAnimations);
        }

        // Function to update animation count display
        function updateAnimationCount(visibleCount) {
            updateFilterResultCount(visibleCount, allAnimations.length);
        }

        // Update total count display
        function updateTotalCount() {
            const totalCount = paginationState.totalItems > 0 ? paginationState.totalItems : allAnimations.length;
            updateFilterResultCount(totalCount, totalCount);
        }

        // Remove duplicate animations based on ID and title
        function removeDuplicateAnimations(animations) {
            console.log(`Checking for duplicates among ${animations.length} animations`);

            // Define problematic animations that need special handling
            const knownDuplicatePatterns = [
                'join clyde',
                'virtue',
                'mage ai',
                'smartlead',
                'chatbase',
                'raycast',
                'midjourney'
            ];

            // Track unique IDs to filter out duplicates
            const seenIds = new Set();
            const uniqueAnimations = [];
            const duplicates = [];

            // First pass: Check for exact duplicate IDs (most reliable method)
            animations.forEach(animation => {
                if (!animation || !animation.id) return;

                // Use ID as primary key if we've seen it already
                if (seenIds.has(animation.id)) {
                    duplicates.push({
                        id: animation.id,
                        title: animation.title,
                        reason: 'duplicate ID'
                    });
                    return;
                }

                // Otherwise, add it to our unique animations
                seenIds.add(animation.id);
                uniqueAnimations.push(animation);
            });

            console.log(`After removing duplicate IDs: ${uniqueAnimations.length} animations remain`);
            console.log(`Removed ${duplicates.length} duplicates`);

            // Log some debug info about the duplicates
            if (duplicates.length > 0) {
                console.log(`Example duplicates:`, duplicates.slice(0, 5));
            }

            return uniqueAnimations;
        }

        // Display API error message
        function showApiError(message) {
            // Hide loading indicator
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }

            // Show error message
            const container = document.getElementById('animations-container');
            if (container) {
                container.innerHTML = '';

                const errorContainer = document.createElement('div');
                errorContainer.style.padding = '20px';
                errorContainer.style.textAlign = 'center';
                errorContainer.style.color = 'var(--text-color)';
                errorContainer.style.backgroundColor = 'var(--error-background)';
                errorContainer.style.borderRadius = '8px';
                errorContainer.style.margin = '20px auto';
                errorContainer.style.maxWidth = '90%';
                errorContainer.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';

                const errorTitle = document.createElement('h3');
                errorTitle.textContent = 'Error Loading Animations';
                errorTitle.style.marginBottom = '12px';
                errorTitle.style.color = 'var(--error-color)';
                errorContainer.appendChild(errorTitle);

                const errorMessage = document.createElement('p');
                errorMessage.textContent = message;
                errorMessage.style.marginBottom = '12px';
                errorContainer.appendChild(errorMessage);

                // Add troubleshooting section
                const troubleshooting = document.createElement('div');
                troubleshooting.style.marginTop = '20px';
                troubleshooting.style.padding = '10px';
                troubleshooting.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                troubleshooting.style.borderRadius = '6px';
                troubleshooting.style.fontSize = '13px';

                const troubleshootingTitle = document.createElement('h4');
                troubleshootingTitle.textContent = 'Troubleshooting';
                troubleshootingTitle.style.marginBottom = '8px';
                troubleshooting.appendChild(troubleshootingTitle);

                const troubleshootingList = document.createElement('ul');
                troubleshootingList.style.textAlign = 'left';
                troubleshootingList.style.paddingLeft = '20px';

                const tips = [
                    'Check your internet connection',
                    'If you are behind a corporate firewall, try connecting from a different network',
                    'Try refreshing the plugin',
                    'Clear your browser cache and try again',
                    'The Ripplix API may be temporarily unavailable'
                ];

                tips.forEach(tip => {
                    const item = document.createElement('li');
                    item.textContent = tip;
                    item.style.marginBottom = '5px';
                    troubleshootingList.appendChild(item);
                });

                troubleshooting.appendChild(troubleshootingList);
                errorContainer.appendChild(troubleshooting);

                // Add support contact info
                const supportText = document.createElement('p');
                supportText.textContent = 'Please contact support@ripplix.com for assistance.';
                supportText.style.marginTop = '15px';
                supportText.style.fontSize = '13px';
                errorContainer.appendChild(supportText);

                // Add retry button
                const retryButton = document.createElement('button');
                retryButton.textContent = 'Try Again';
                retryButton.className = 'retry-button';
                retryButton.style.marginTop = '15px';
                retryButton.style.padding = '8px 16px';
                retryButton.style.backgroundColor = 'var(--primary-color)';
                retryButton.style.color = 'white';
                retryButton.style.border = 'none';
                retryButton.style.borderRadius = '4px';
                retryButton.style.cursor = 'pointer';
                retryButton.addEventListener('click', () => {
                    // Reload the plugin
                    window.location.reload();
                });
                errorContainer.appendChild(retryButton);

                container.appendChild(errorContainer);
            }
        }

        // Update platform dropdown with API data
        function updatePlatformDropdown(platforms) {
            const platformSelect = document.getElementById('platform-select');
            if (!platformSelect) return;

            // Clear existing options except the first "All" option
            while (platformSelect.options.length > 1) {
                platformSelect.remove(1);
            }

            // Add new platform options
            platforms.forEach(platform => {
                const option = document.createElement('option');
                option.value = platform;
                option.textContent = platform;
                platformSelect.appendChild(option);
            });
        }

        // Fix Cloudflare URL to direct download
        function fixCloudflareUrl(url) {
            console.log("Fixing Cloudflare URL:", url);

            // If already in the correct format, return as is
            if (url.includes('/downloads/default.mp4')) {
                console.log("URL already has /downloads/default.mp4 format, using as is");
                return url;
            }

            // Extract the video ID using regex pattern for 32-character hex IDs
            const hexPattern = /([a-f0-9]{32})/i;
            const matches = url.match(hexPattern);

            if (matches && matches[1]) {
                const videoId = matches[1];
                console.log("Extracted video ID:", videoId);
                const directUrl = `https://customer-jvsp4o8np8zajpgo.cloudflarestream.com/${videoId}/downloads/default.mp4`;
                console.log("Generated direct download URL:", directUrl);
                return directUrl;
            }

            console.warn("Could not extract video ID from URL, using original:", url);
            return url;
        }

        // Create animation grid
        function createAnimationGrid(animations) {
            console.log(`Creating animation grid with ${animations ? animations.length : 0} animations`);

            // Get container element
            const container = document.getElementById('animations-container');
            if (!container) {
                console.error("Error: animations-container not found!");

                // Try to find or create the main content area
                let mainContent = document.querySelector('.main-content');
                if (!mainContent) {
                    console.log("Main content not found, creating it");
                    mainContent = document.createElement('div');
                    mainContent.className = 'main-content';
                    document.body.appendChild(mainContent);
                }

                // Create the animations container
                const newContainer = document.createElement('div');
                newContainer.id = 'animations-container';
                mainContent.appendChild(newContainer);

                console.log("Created new animations container");

                // Now try again with the new container
                createAnimationGrid(animations);
                return;
            }

            // Hide loading indicator
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }

            // Clear container
            container.innerHTML = '';
            console.log("Cleared animations container");

            // Create grid element
            const grid = document.createElement('div');
            grid.id = 'animation-grid';
            grid.className = 'animation-grid';
            container.appendChild(grid);
            console.log("Created animation grid element");

            // Check if we have animations
            if (!animations || animations.length === 0) {
                console.warn("No animations to display");
                const noResults = document.createElement('div');
                noResults.className = 'no-results';
                noResults.textContent = 'No animations found. Try adjusting your filters.';
                container.appendChild(noResults);
                return;
            }

            console.log(`Adding ${animations.length} animation cards to grid`);
            // Add animation cards to grid
            animations.forEach((animation, index) => {
                try {
                    const card = createAnimationCard(animation);
                    if (card) {
                        grid.appendChild(card);
                    } else {
                        console.warn(`Failed to create card for animation ${index}:`, animation);
                    }
                } catch (error) {
                    console.error(`Error creating card for animation ${index}:`, error, animation);
                }
            });

            console.log(`Added ${grid.children.length} animation cards to grid`);
            // Initialize lazy loading for videos
            initLazyLoading();

            // Remove any loading indicators
            document.querySelectorAll('.loading-container').forEach(container => {
                container.style.display = 'none';
            });
        }

        // Create a single animation card
        function createAnimationCard(animation) {
            // Skip invalid animations
            if (!animation || !animation.id) {
                return null;
            }

            // Create card element
            const card = document.createElement('div');
            card.className = 'animation-card';
            card.setAttribute('data-id', animation.id);

            // 1. Video container
            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-container';

            // Add loading text
            const loadingText = document.createElement('div');
            loadingText.className = 'loading-text';
            loadingText.textContent = 'Loading...';
            videoContainer.appendChild(loadingText);

            // Create placeholder for video - we'll only load it when visible
            const videoPlaceholder = document.createElement('div');
            videoPlaceholder.className = 'video-placeholder';
            videoPlaceholder.dataset.videoUrl = animation.video_url || animation.animation_url || '';
            videoPlaceholder.dataset.videoId = animation.id;

            // Add play overlay
            const playOverlay = document.createElement('div');
            playOverlay.className = 'play-overlay show-play';

            const playIcon = document.createElement('div');
            playIcon.className = 'play-icon';
            playIcon.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 5V19L19 12L8 5Z" fill="white"/></svg>';
            playOverlay.appendChild(playIcon);

            videoContainer.appendChild(videoPlaceholder);
            videoContainer.appendChild(playOverlay);

            // Add poster image instead of loading video immediately
            videoContainer.style.backgroundImage = `url('https://www.ripplix.com/wp-content/uploads/2024/12/Placeholder-animations.svg')`;
            videoContainer.style.backgroundSize = 'cover';
            videoContainer.style.backgroundPosition = 'center';

            // 2. Product section
            const productSection = document.createElement('div');
            productSection.className = 'product-section';

            // Standardize product data
            const product = animation.product || 'Ripplix';

            // Prioritize product_logo over logo
            const logo = animation.product_logo || animation.logo || '';

            // Add product logo if available - with lazy loading
            if (logo && isValidUrl(logo)) {
                const logoContainer = document.createElement('div');
                logoContainer.className = 'product-logo-container';

                // Use a placeholder first
                const logoPlaceholder = document.createElement('div');
                logoPlaceholder.className = 'product-logo-placeholder';
                logoPlaceholder.dataset.logoUrl = logo;
                logoPlaceholder.dataset.logoAlt = product;
                logoPlaceholder.style.width = '24px';
                logoPlaceholder.style.height = '24px';
                logoPlaceholder.style.backgroundColor = '#f0f0f0';
                logoPlaceholder.style.borderRadius = '4px';

                logoContainer.appendChild(logoPlaceholder);
                productSection.appendChild(logoContainer);
            } else {
                // Add a spacer to maintain consistent layout if there's no logo
                const spacer = document.createElement('div');
                spacer.className = 'product-logo-spacer';
                spacer.style.width = '8px'; // Small spacer
                productSection.appendChild(spacer);
            }

            // Add product name (using product field as product name per API)
            const productName = document.createElement('div');
            productName.className = 'product-name';
            productName.textContent = product;
            productSection.appendChild(productName);

            // 3. Interaction container
            const interactionContainer = document.createElement('div');
            interactionContainer.className = 'interaction-container';

            // Handle both single string and array of interactions
            let interactions = [];
            if (typeof animation.interaction === 'string') {
                interactions = [animation.interaction];
            } else if (Array.isArray(animation.interaction)) {
                interactions = animation.interaction;
            }

            // Create tags for each interaction - limit to 3 max for performance
            const maxTags = 3;
            interactions.slice(0, maxTags).forEach(interaction => {
                if (interaction && interaction.trim()) {
                    const tag = document.createElement('span');
                    tag.className = 'interaction-tag';
                    tag.textContent = interaction.trim();
                    interactionContainer.appendChild(tag);
                }
            });

            // 4. Add to Figma button
            const addButton = document.createElement('button');
            addButton.className = 'add-button';
            addButton.textContent = 'Add to Figma';
            addButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent card click
                addToFigma(animation);
            });

            // Assemble card
            card.appendChild(videoContainer);
            card.appendChild(productSection);
            card.appendChild(interactionContainer);
            card.appendChild(addButton);

            // Mark card as needing initialization when it becomes visible
            card.dataset.needsInit = 'true';

            return card;
        }

        // Initialize lazy loading of videos and images
        function initLazyLoading() {
            // Use IntersectionObserver for better performance
            if ('IntersectionObserver' in window) {
                // Create a new observer or use existing one
                if (!window.lazyLoadObserver) {
                    window.lazyLoadObserver = new IntersectionObserver((entries, observer) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const card = entry.target;

                                // Only initialize once
                                if (card.dataset.needsInit === 'true') {
                                    // Initialize video with a small delay to prevent UI jank
                                    setTimeout(() => {
                                        // Initialize video
                                        const videoPlaceholder = card.querySelector('.video-placeholder');
                                        if (videoPlaceholder && videoPlaceholder.dataset.videoUrl) {
                                            initializeVideo(card, videoPlaceholder.dataset.videoUrl);
                                        }

                                        // Initialize logo
                                        const logoPlaceholder = card.querySelector('.product-logo-placeholder');
                                        if (logoPlaceholder && logoPlaceholder.dataset.logoUrl) {
                                            initializeLogo(logoPlaceholder);
                                        }

                                        // Mark as initialized
                                        card.dataset.needsInit = 'false';
                                    }, 100);
                                }

                                // Stop observing this card after it's initialized
                                observer.unobserve(card);
                            }
                        });
                    }, {
                        rootMargin: '200px', // Increased margin to start loading earlier
                        threshold: 0.1
                    });
                }

                // Observe all cards that need initialization
                document.querySelectorAll('.animation-card[data-needs-init="true"]').forEach(card => {
                    window.lazyLoadObserver.observe(card);
                });
            } else {
                // Fallback for browsers without IntersectionObserver
                initializeAllVisibleCards();
            }
        }

        // Initialize video for a card
        function initializeVideo(card, videoUrl) {
            if (!videoUrl) return;

            const videoContainer = card.querySelector('.video-container');
            if (!videoContainer) return;

            // Create and set up video element
            const video = document.createElement('video');
            video.className = 'animation-video';

            // Format the URL if needed
            if (videoUrl.includes('cloudflarestream')) {
                videoUrl = fixCloudflareUrl(videoUrl);
            }

            // Set up video attributes
            video.src = videoUrl;
            video.muted = true;
            video.loop = true;
            video.playsInline = true;
            video.loading = 'lazy';

            // Replace placeholder with actual video
            const placeholder = videoContainer.querySelector('.video-placeholder');
            if (placeholder) {
                videoContainer.replaceChild(video, placeholder);
            } else {
                videoContainer.appendChild(video);
            }

            // Update loading text and play button
            const loadingText = videoContainer.querySelector('.loading-text');
            if (loadingText) loadingText.style.display = 'none';

            const playOverlay = videoContainer.querySelector('.play-overlay');

            // Add event listeners
            video.addEventListener('loadeddata', () => {
                // Clear background image
                videoContainer.style.backgroundImage = 'none';

                // Try to play the video
                video.play().catch(err => {
                    if (playOverlay) playOverlay.classList.add('show-play');
                });
            });

            video.addEventListener('error', () => {
                // Keep the placeholder background on error
                if (loadingText) {
                    loadingText.textContent = 'Video failed to load';
                    loadingText.style.display = 'block';
                }
                if (playOverlay) playOverlay.classList.add('show-play');
            });

            video.addEventListener('play', () => {
                if (playOverlay) playOverlay.classList.remove('show-play');
            });

            video.addEventListener('pause', () => {
                if (playOverlay) playOverlay.classList.add('show-play');
            });

            // Add click handler to the container
            videoContainer.addEventListener('click', () => {
                if (video.paused) {
                    video.play().catch(err => console.error('Play error:', err));
                } else {
                    video.pause();
                }
            });
        }

        // Initialize logo image
        function initializeLogo(placeholder) {
            const logoUrl = placeholder.dataset.logoUrl;
            const logoAlt = placeholder.dataset.logoAlt || 'Logo';

            if (!logoUrl) return;

            const logoImg = document.createElement('img');
            logoImg.className = 'product-logo';
            logoImg.src = logoUrl;
            logoImg.alt = logoAlt;
            logoImg.width = 24;
            logoImg.height = 24;

            // Handle error for any image format
            logoImg.onerror = function() {
                // Keep the placeholder on error
                console.warn('Failed to load logo:', logoUrl);
            };

            // Replace placeholder on successful load
            logoImg.onload = function() {
                const container = placeholder.parentElement;
                if (container) {
                    container.replaceChild(logoImg, placeholder);
                }
            };
        }

        // Fallback for browsers without IntersectionObserver
        function initializeAllVisibleCards() {
            document.querySelectorAll('.animation-card[data-needs-init="true"]').forEach(card => {
                // Initialize video
                const videoPlaceholder = card.querySelector('.video-placeholder');
                if (videoPlaceholder && videoPlaceholder.dataset.videoUrl) {
                    initializeVideo(card, videoPlaceholder.dataset.videoUrl);
                }

                // Initialize logo
                const logoPlaceholder = card.querySelector('.product-logo-placeholder');
                if (logoPlaceholder && logoPlaceholder.dataset.logoUrl) {
                    initializeLogo(logoPlaceholder);
                }

                // Mark as initialized
                card.dataset.needsInit = 'false';
            });
        }

        // Get currently visible animations based on pagination and filters
        function getVisibleAnimations() {
            // Debug log for active filters
            console.log("Active filters:", JSON.stringify(activeFilters));

            // Get search query once outside the loop for better performance
            const searchInput = document.getElementById('search-input');
            const query = searchInput ? searchInput.value.toLowerCase().trim() : '';

            // Check if any filter is active
            const isFiltered = activeFilters.platform || activeFilters.interaction || query;

            // Apply filters first
            const filteredAnimations = allAnimations.filter(animation => {
                // Check if animation matches all active filters
                // Platform filter
                const matchesPlatform = !activeFilters.platform || animation.platform === activeFilters.platform;
                if (!matchesPlatform) return false;

                // For interaction, check if it's in the array or matches the string
                let matchesInteraction = true;
                if (activeFilters.interaction) {
                    if (Array.isArray(animation.interaction)) {
                        // Case-insensitive comparison for better matching
                        matchesInteraction = animation.interaction.some(interaction => {
                            if (!interaction) return false;
                            return interaction.toLowerCase() === activeFilters.interaction.toLowerCase();
                        });
                    } else if (typeof animation.interaction === 'string') {
                        if (!animation.interaction) {
                            matchesInteraction = false;
                        } else {
                            matchesInteraction = animation.interaction.toLowerCase() === activeFilters.interaction.toLowerCase();
                        }
                    } else {
                        matchesInteraction = false;
                    }
                }
                if (!matchesInteraction) return false;

                // Check if animation matches search query
                if (query) {
                    const matchesSearch =
                        animation.title.toLowerCase().includes(query) ||
                        (animation.platform && animation.platform.toLowerCase().includes(query)) ||
                        (Array.isArray(animation.interaction) ?
                            animation.interaction.some(i => i && i.toLowerCase().includes(query)) :
                            (animation.interaction && animation.interaction.toLowerCase().includes(query))) ||
                        (animation.description && animation.description.toLowerCase().includes(query));

                    if (!matchesSearch) return false;
                }

                // If we got here, all filters passed
                return true;
            });

            // Log filtered results
            console.log(`Filtered animations: ${filteredAnimations.length} of ${allAnimations.length} total animations`);

            // If filters are applied, return all matching animations without pagination
            if (isFiltered) {
                console.log(`Showing all ${filteredAnimations.length} matching results without pagination`);
                return filteredAnimations;
            } else {
                // Only apply pagination for full, unfiltered list
                const startIndex = 0;
                const endIndex = paginationState.currentPage * paginationState.itemsPerPage;
                const visibleAnimations = filteredAnimations.slice(startIndex, endIndex);
                console.log(`Showing ${visibleAnimations.length} of ${filteredAnimations.length} total animations with pagination`);
                return visibleAnimations;
            }
        }

        // Load more animations
        async function loadMoreAnimations() {
            // Get search query
            const searchInput = document.getElementById('search-input');
            const query = searchInput ? searchInput.value.toLowerCase().trim() : '';

            // Check if any filter is active
            const isFiltered = activeFilters.platform || activeFilters.interaction || query;

            // Don't load more if filters are applied - we already show all matching results
            if (isFiltered) {
                console.log("Not loading more animations while filters are applied");
                return;
            }

            if (paginationState.isLoading || !paginationState.hasMoreItems) {
                return; // Prevent multiple simultaneous loads or if no more items
            }

            paginationState.isLoading = true;
            console.log(`Loading more animations, page ${paginationState.currentPage + 1}`);

            // Show loading indicator
            const loadingMore = document.getElementById('loading-more');
            if (loadingMore) {
                loadingMore.classList.add('visible');
            }

            try {
                // Increment page counters
                paginationState.currentPage++;
                paginationState.apiPage++;

                // Always try to fetch more from the API with true lazy loading
                console.log(`Fetching page ${paginationState.apiPage} from API`);
                let newAnimations = [];

                try {
                    // Fetch next page from API
                    const apiUrl = `https://www.ripplix.com/wp-json/ripplix/v1/animations?per_page=${paginationState.itemsPerPage}&page=${paginationState.apiPage}`;
                    const response = await fetch(apiUrl);

                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }

                    const data = await response.json();

                    if (data && Array.isArray(data.animations)) {
                        newAnimations = data.animations;

                        // Add to our existing animations
                        for (const animation of newAnimations) {
                            // Check if we already have this animation (avoid duplicates)
                            if (!allAnimations.some(a => a.id === animation.id)) {
                                allAnimations.push(animation);
                            }
                        }

                        console.log(`Added ${newAnimations.length} new animations from API`);

                        // Check if we've reached the end
                        if (newAnimations.length < paginationState.itemsPerPage) {
                            paginationState.hasMoreItems = false;
                            console.log("Reached the end of API data");
                        }
                    } else {
                        console.warn("Invalid API response format");
                        paginationState.hasMoreItems = false;
                    }
                } catch (error) {
                    console.error("Error fetching more animations:", error);
                    // Don't mark as no more items to allow retry
                }

                // Special case: If we didn't get any new animations but expected some,
                // this could be a filter issue - try one more time with the next page
                if (newAnimations.length === 0 && paginationState.hasMoreItems) {
                    paginationState.apiPage++;
                    try {
                        console.log(`Retrying with next page ${paginationState.apiPage}`);
                        const retryUrl = `https://www.ripplix.com/wp-json/ripplix/v1/animations?per_page=${paginationState.itemsPerPage}&page=${paginationState.apiPage}`;
                        const retryResponse = await fetch(retryUrl);

                        if (retryResponse.ok) {
                            const retryData = await retryResponse.json();

                            if (retryData && Array.isArray(retryData.animations)) {
                                newAnimations = retryData.animations;

                                // Add to our existing animations
                                for (const animation of newAnimations) {
                                    if (!allAnimations.some(a => a.id === animation.id)) {
                                        allAnimations.push(animation);
                                    }
                                }

                                console.log(`Added ${newAnimations.length} new animations from API (retry)`);

                                if (newAnimations.length < paginationState.itemsPerPage) {
                                    paginationState.hasMoreItems = false;
                                }
                            }
                        }
                    } catch (retryError) {
                        console.error("Error in retry fetch:", retryError);
                    }
                }

                // After getting new data, update the grid with new animations
                await updateGridWithNewAnimations();

            } catch (error) {
                console.error("Error in loadMoreAnimations:", error);
            } finally {
                // Hide loading indicator with a slight delay for smoother UX
                setTimeout(() => {
                    if (loadingMore) {
                        loadingMore.classList.remove('visible');
                    }

                    paginationState.isLoading = false;

                    // Update the sentinel position
                    positionLoadMoreSentinel();
                }, 300);
            }
        }

        // Update grid with newly loaded animations
        async function updateGridWithNewAnimations() {
            // Get animations visible after applying filters
            const visibleAnimations = getVisibleAnimations();
            const grid = document.getElementById('animation-grid');

            if (!grid) return;

            // Get current animation IDs to avoid duplicates
            const existingIds = Array.from(grid.querySelectorAll('.animation-card'))
                .map(card => card.getAttribute('data-id'));

            // Create and add new cards for animations not already in the grid
            let newCardsAdded = 0;

            // Add a slight delay between each card for smoother rendering
            for (const animation of visibleAnimations) {
                if (!existingIds.includes(String(animation.id))) {
                    const card = createAnimationCard(animation);
                    if (card) {
                        grid.appendChild(card);
                        newCardsAdded++;

                        // Add a small delay every few cards to prevent UI freezing
                        if (newCardsAdded % 4 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    }
                }
            }

            console.log(`Added ${newCardsAdded} new animation cards to the grid`);

            // Initialize lazy loading for new cards
            initLazyLoading();

            // Update counts
            updateAnimationCount(grid.querySelectorAll('.animation-card').length);

            // If we didn't add any new cards but should have more, try to load more
            if (newCardsAdded === 0 && paginationState.hasMoreItems) {
                console.log("No new cards added but more items expected, will try again on next scroll");
            }

            return newCardsAdded;
        }

        // Set up scroll listener for pagination
        function setupScrollListener() {
            console.log("Setting up scroll listener for pagination using IntersectionObserver");

            // Create the sentinel element if it doesn't exist
            createLoadMoreSentinel();

            // If we already have an observer, disconnect it first
            if (window.loadMoreObserver) {
                window.loadMoreObserver.disconnect();
            }

            // Set up IntersectionObserver to detect when sentinel is visible
            const observerOptions = {
                root: null, // Use viewport as root
                rootMargin: '300px 0px', // Start loading when sentinel is within 300px of viewport
                threshold: 0.1 // Trigger when at least 10% visible
            };

            try {
                // Create a new observer and keep a reference to it
                window.loadMoreObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && !paginationState.isLoading) {
                            // Get search query
                            const searchInput = document.getElementById('search-input');
                            const query = searchInput ? searchInput.value.toLowerCase().trim() : '';

                            // Check if any filter is active
                            const isFiltered = activeFilters.platform || activeFilters.interaction || query;

                            // Only load more if no filters are applied
                            if (!isFiltered) {
                                console.log('Load more sentinel is visible, loading more animations');

                                // Show a small delay to prevent too rapid loading
                                setTimeout(() => {
                                    loadMoreAnimations();
                                }, 100);
                            }
                        }
                    });
                }, observerOptions);

                // Start observing the sentinel element
                const sentinel = document.getElementById('load-more-sentinel');
                if (sentinel) {
                    window.loadMoreObserver.observe(sentinel);
                    console.log('Observing load more sentinel');
                }

                // Also setup fallback scroll detection for browsers that don't support IntersectionObserver
                if (!('IntersectionObserver' in window)) {
                    setupFallbackScrollListener();
                }
            } catch (error) {
                console.error('Error setting up IntersectionObserver:', error);
                // Fall back to traditional scroll listener
                setupFallbackScrollListener();
            }
        }

        // Position the load more sentinel element
        function positionLoadMoreSentinel() {
            const sentinel = document.getElementById('load-more-sentinel');
            if (!sentinel) return;

            // Position at the bottom of the grid
            const grid = document.getElementById('animation-grid');
            if (!grid || !grid.lastElementChild) return;

            // Make sure the sentinel is appended after the last grid item
            const mainContent = document.querySelector('.main-content');
            if (mainContent) {
                // Position it right after the grid
                mainContent.appendChild(sentinel);

                // Make sure the observer is still watching it
                if (window.loadMoreObserver) {
                    window.loadMoreObserver.observe(sentinel);
                }
            }
        }

        // Set up scroll direction detection for showing/hiding search bar
        function setupScrollDirectionDetection() {
            const searchFilters = document.querySelector('.search-and-filters');
            let lastScrollTop = 0;

            window.addEventListener('scroll', () => {
                const currentScrollTop = window.scrollY || document.documentElement.scrollTop;

                // Determine scroll direction
                if (currentScrollTop > lastScrollTop) {
                    // Scrolling down - hide search bar
                    searchFilters.style.transform = 'translateY(-100%)';
                } else {
                    // Scrolling up - show search bar
                    searchFilters.style.transform = 'translateY(0)';
                }

                lastScrollTop = currentScrollTop;
            }, {
                passive: true
            }); // For better performance
        }

        // Open preview modal
        function openPreview(animation) {
            const modal = document.getElementById('preview-modal');

            // Set title and meta
            document.getElementById('preview-title').textContent = animation.title;

            const previewMeta = document.getElementById('preview-meta');
            previewMeta.innerHTML = '';

            // Add product info
            if (animation.product) {
                const productInfo = document.createElement('div');
                productInfo.style.display = 'flex';
                productInfo.style.alignItems = 'center';
                productInfo.style.marginBottom = '12px';

                if (animation.product_logo) {
                    const logoImg = document.createElement('img');
                    logoImg.src = animation.product_logo;
                    logoImg.style.height = '24px';
                    logoImg.style.marginRight = '8px';
                    productInfo.appendChild(logoImg);
                }

                const productName = document.createElement('span');
                productName.textContent = animation.product;
                productName.style.color = '#ff5f1f';
                productName.style.fontWeight = '500';
                productInfo.appendChild(productName);

                previewMeta.appendChild(productInfo);
            }

            // Add platform tag
            if (animation.platform) {
                const platformTag = document.createElement('span');
                platformTag.className = 'meta-tag';
                platformTag.textContent = animation.platform;
                previewMeta.appendChild(platformTag);
            }

            // Add interaction tag(s)
            if (animation.interaction) {
                const interactions = Array.isArray(animation.interaction) ?
                    animation.interaction : [animation.interaction];

                interactions.forEach(interaction => {
                    if (!interaction) return;

                    const interactionTag = document.createElement('span');
                    interactionTag.className = 'meta-tag';
                    interactionTag.textContent = interaction;
                    previewMeta.appendChild(interactionTag);
                });
            }

            // Set video
            const videoWrapper = modal.querySelector('.video-wrapper');
            videoWrapper.innerHTML = '';

            const video = document.createElement('video');
            video.style.width = '100%';
            video.style.height = 'auto';
            video.style.maxHeight = '350px';
            video.style.objectFit = 'contain';
            video.controls = true;
            video.muted = true;
            video.autoplay = true;
            video.loop = true;
            video.playsInline = true;
            video.src = animation.video_url;

            videoWrapper.appendChild(video);

            // Set add button action
            document.getElementById('preview-add').onclick = () => {
                addToFigma(animation);
                closePreview();
            };

            // Set close button action
            document.getElementById('preview-close').onclick = closePreview;

            // Add click outside to close
            modal.onclick = (e) => {
                if (e.target === modal) {
                    closePreview();
                }
            };

            // Show modal
            modal.style.display = 'flex';

            // Play video
            video.play().catch(err => console.warn("Preview video autoplay failed:", err));
        }

        // Close preview modal
        function closePreview() {
            const modal = document.getElementById('preview-modal');

            // Stop any videos
            const videos = modal.querySelectorAll('video');
            videos.forEach(video => {
                try {
                    video.pause();
                } catch (e) {
                    console.error("Error stopping video:", e);
                }
            });

            // Hide modal
            modal.style.display = 'none';
        }

        // Add to Figma
        function addToFigma(animation) {
            console.log("Adding animation to Figma:", animation);

            if (!animation || !animation.id) {
                console.error("Invalid animation data");
                return;
            }

            try {
                // Normalize video URL
                let videoUrl = animation.video_url || animation.animation_url || '';
                if (videoUrl.includes('cloudflarestream')) {
                    videoUrl = fixCloudflareUrl(videoUrl);
                }

                // Prioritize product_logo over logo to match the product branding
                const logoUrl = animation.product_logo || animation.logo || '';

                // Normalize data for Figma
                const dataForFigma = {
                    id: animation.id,
                    title: animation.title || 'Untitled Animation',
                    url: animation.url || '',
                    video_url: videoUrl,
                    product: animation.product || 'Ripplix',
                    product_logo: logoUrl, // Explicitly set product_logo
                    logo: logoUrl, // Keep logo for backward compatibility
                    description: animation.description || ''
                };

                // Log the data we're sending
                console.log("Sending data to Figma:", dataForFigma);

                // Send data to Figma
                parent.postMessage({
                    pluginMessage: {
                        type: 'add-animation',
                        animation: dataForFigma
                    }
                }, '*');

                // Show success feedback
                showToast(`Added "${dataForFigma.title}" to Figma`);

            } catch (error) {
                console.error("Error adding animation to Figma:", error);
                showToast("Error adding animation to Figma", true);
            }
        }

        // Show toast notification
        function showToast(message, isError = false) {
            // Create toast container if it doesn't exist
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.style.position = 'fixed';
                toastContainer.style.bottom = '20px';
                toastContainer.style.left = '50%';
                toastContainer.style.transform = 'translateX(-50%)';
                toastContainer.style.zIndex = '9999';
                document.body.appendChild(toastContainer);
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.style.backgroundColor = isError ? 'var(--error-color)' : 'var(--success-color)';
            toast.style.color = 'white';
            toast.style.padding = '12px 20px';
            toast.style.borderRadius = '6px';
            toast.style.margin = '8px';
            toast.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
            toast.style.textAlign = 'center';
            toast.style.minWidth = '200px';
            toast.style.maxWidth = '300px';
            toast.style.opacity = '0';
            toast.style.transition = 'opacity 0.3s ease';
            toast.textContent = message;

            // Add toast to container
            toastContainer.appendChild(toast);

            // Show toast
            setTimeout(() => {
                toast.style.opacity = '1';
            }, 10);

            // Hide toast after 3 seconds
            setTimeout(() => {
                toast.style.opacity = '0';

                // Remove toast from DOM after fade out
                setTimeout(() => {
                    toast.remove();
                }, 300);
            }, 3000);
        }

        // Set up event handlers
        function setupEventHandlers() {
            // Set up search
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                // Use debounced search for input to prevent excessive filtering during typing
                searchInput.addEventListener('input', debounce(handleSearch, 300));
            }

            // Set up search button
            const searchButton = document.querySelector('.search-button');
            if (searchButton) {
                // Button click should search immediately
                searchButton.addEventListener('click', handleSearch);
            }

            // Set up logo click handler
            const logoContainer = document.querySelector('.logo-container');
            if (logoContainer) {
                logoContainer.addEventListener('click', resetToInitialState);
                logoContainer.style.cursor = 'pointer'; // Add pointer cursor to indicate it's clickable
            }

            // Set up platform dropdown
            const platformSelect = document.getElementById('platform-select');
            if (platformSelect) {
                platformSelect.addEventListener('change', () => {
                    // Clear previous platform filter
                    activeFilters.platform = platformSelect.value || null;

                    // Apply filters
                    applyFilters();
                });

                // Add hover effect enhancement
                const options = platformSelect.querySelectorAll('option');
                options.forEach(option => {
                    option.addEventListener('mouseover', () => {
                        option.style.backgroundColor = '#F2EDFF';
                        option.style.color = '#3F2B87';
                    });

                    option.addEventListener('mouseout', () => {
                        if (!option.selected) {
                            option.style.backgroundColor = '';
                            option.style.color = '';
                        }
                    });
                });
            }

            // Set up close button
            const closeBtn = document.getElementById('close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    parent.postMessage({
                        pluginMessage: {
                            type: 'cancel'
                        }
                    }, '*');
                });
            }

            // Set up filter tags
            const filterTags = document.querySelectorAll('.filter-tag');
            filterTags.forEach(tag => {
                // Add click handler
                tag.addEventListener('click', () => {
                    const filterType = tag.getAttribute('data-filter');
                    const filterValue = tag.getAttribute('data-value');

                    // Toggle filter
                    if (activeFilters[filterType] === filterValue) {
                        // If already active, clear filter
                        activeFilters[filterType] = null;

                        // Reset style
                        tag.classList.remove('active');
                    } else {
                        // Clear other filters of same type
                        document.querySelectorAll(`.filter-tag[data-filter="${filterType}"]`).forEach(t => {
                            t.classList.remove('active');
                        });

                        // Set new filter
                        activeFilters[filterType] = filterValue;

                        // Update style
                        tag.classList.add('active');

                        // Ensure the clicked tag is visible by scrolling it into view
                        tag.scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest',
                            inline: 'center'
                        });
                    }

                    // Apply filters
                    applyFilters();
                });

                // Add hover effect logic
                tag.addEventListener('mouseover', () => {
                    if (!tag.classList.contains('active')) {
                        tag.style.backgroundColor = '#F2EDFF';
                        tag.style.color = '#3F2B87';
                    }
                });

                tag.addEventListener('mouseout', () => {
                    if (!tag.classList.contains('active')) {
                        tag.style.backgroundColor = '';
                        tag.style.color = '';
                    }
                });
            });

            // Add ESC key handler
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closePreview();
                }
            });

            // Set up scroll direction detection for search bar
            setupScrollDirectionDetection();
        }

        // Apply all filters and search
        function applyFilters() {
            // Reset pagination state
            paginationState.currentPage = 1;

            // Get the grid
            const grid = document.getElementById('animation-grid');
            if (!grid) return;

            // Clear the grid
            grid.innerHTML = '';

            // Show loading indicator while filtering
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'loading-container';
            loadingIndicator.style.padding = '20px';
            loadingIndicator.style.textAlign = 'center';

            loadingIndicator.innerHTML = `
                <div class="loading-dots">
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                </div>
                <p style="margin-top: 16px; color: var(--light-text);">Filtering animations...</p>
            `;

            grid.appendChild(loadingIndicator);

            // Use setTimeout to allow the loading indicator to render
            setTimeout(() => {
                // Remove loading indicator
                grid.removeChild(loadingIndicator);

                // Get search query
                const searchInput = document.getElementById('search-input');
                const query = searchInput ? searchInput.value.toLowerCase().trim() : '';

                // Check if this is a full reset from logo click
                const isReset = document.getElementById('filter-container').hasAttribute('data-reset');

                // Check if any filter is active
                const isFiltered = activeFilters.platform || activeFilters.interaction || query;

                // Get visible animations based on current filters
                let visibleAnimations;

                if (isReset) {
                    // When reset from logo click, show all animations
                    visibleAnimations = allAnimations;
                    console.log(`Logo reset: showing all ${visibleAnimations.length} animations`);
                } else {
                    // Normal filtering behavior
                    visibleAnimations = getVisibleAnimations();
                }

                // Track filtered animations count for later use
                const filteredCount = visibleAnimations.length;

                // Log if we are showing all animations or filtered results
                console.log(`Showing ${isFiltered && !isReset ? 'filtered' : 'all'} animations:`, visibleAnimations.length);

                // Show filtered animations
                if (visibleAnimations.length > 0) {
                    visibleAnimations.forEach(animation => {
                        const card = createAnimationCard(animation);
                        if (card) {
                            grid.appendChild(card);
                        }
                    });

                    // Initialize lazy loading for the new cards
                    initLazyLoading();

                    // Update the animation count display
                    if (isReset) {
                        // When reset from logo, explicitly show the total count
                        updateFilterResultCount(paginationState.totalItems, paginationState.totalItems);
                    } else {
                        // Normal update for search/filter
                        updateAnimationCount(visibleAnimations.length);
                    }

                    // Only use infinite scroll loading for unfiltered view
                    if (!isFiltered || isReset) {
                        // Check if we need to load more data from API to fulfill the grid
                        if (visibleAnimations.length < paginationState.itemsPerPage &&
                            paginationState.hasMoreItems) {

                            console.log("Need more data to fill unfiltered grid, loading from API...");
                            setTimeout(() => {
                                loadMoreAnimations();
                            }, 200);
                        }

                        // Show load more sentinel for infinite scrolling on unfiltered view
                        const sentinel = document.getElementById('load-more-sentinel');
                        if (sentinel) {
                            sentinel.style.display = '';
                            positionLoadMoreSentinel();
                        }
                    } else {
                        // Hide load more sentinel when filtering - we show all results at once
                        const sentinel = document.getElementById('load-more-sentinel');
                        if (sentinel) {
                            sentinel.style.display = 'none';
                        }
                    }
                } else {
                    // Show no results message
                    const noResults = document.createElement('div');
                    noResults.className = 'no-results';
                    noResults.innerHTML = `
                        <div style="margin: 40px 0; text-align: center;">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M15.5 14.5L19 18M10.5 18C6.36 18 3 14.64 3 10.5C3 6.36 6.36 3 10.5 3C14.64 3 18 6.36 18 10.5C18 12.6075 17.1277 14.5163 15.7663 15.9246C14.4371 17.3006 12.5661 18 10.5 18Z" stroke="#999" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            <p style="margin-top: 16px; color: var(--text-color);">No animations match your search.</p>
                            <p style="color: var(--light-text);">Try different filters or search terms.</p>
                        </div>
                    `;
                    grid.appendChild(noResults);

                    // Hide load more sentinel when no results
                    const sentinel = document.getElementById('load-more-sentinel');
                    if (sentinel) {
                        sentinel.style.display = 'none';
                    }
                }
            }, 10);
        }

        // Update count display to show filtered vs total results
        function updateFilterResultCount(filteredCount, totalCount) {
            const countElement = document.getElementById('animation-count');
            const countLabel = document.getElementById('count-label');
            const originalCountEl = document.getElementById('original-count');

            if (countElement && countLabel) {
                // Only format numbers if they're large
                let formattedCount = filteredCount;
                if (filteredCount >= 1000) {
                    formattedCount = (filteredCount / 1000).toFixed(1) + "K";
                }

                // Update the count display
                countElement.textContent = formattedCount;

                // Check if we're filtering
                const isFiltering = filteredCount < totalCount;

                if (isFiltering) {
                    // Show that we're displaying filtered results
                    countLabel.textContent = "Matching Results";

                    // Show original count if available
                    if (originalCountEl) {
                        originalCountEl.textContent = `(of ${totalCount})`;
                        originalCountEl.style.display = 'inline';
                    }
                } else {
                    // Standard label when showing all results
                    countLabel.textContent = "Animations";

                    // Hide original count when not filtering
                    if (originalCountEl) {
                        originalCountEl.style.display = 'none';
                    }
                }
            }
        }

        // Handle search
        function handleSearch() {
            applyFilters();
        }

        // Debounce function to limit how often a function can be called
        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(context, args);
                }, wait);
            };
        }

        // Update interaction filters with API data
        function updateInteractionFilters(interactions) {
            const filterContainer = document.getElementById('filter-container');
            if (!filterContainer) return;

            // Clear existing filters except for platform filters
            const platformFilters = document.querySelectorAll('.filter-button[data-type="platform"]');
            filterContainer.innerHTML = '';

            // Add platform filters back
            platformFilters.forEach(filter => {
                filterContainer.appendChild(filter.cloneNode(true));
            });

            // Add interaction filters
            interactions.forEach(interaction => {
                if (!interaction) return;

                const button = document.createElement('button');
                button.className = 'filter-button';
                button.dataset.type = 'interaction';
                button.dataset.value = interaction;
                button.textContent = interaction;
                button.onclick = toggleFilter;

                filterContainer.appendChild(button);
            });

            // Re-attach click handlers
            document.querySelectorAll('.filter-button').forEach(button => {
                button.onclick = toggleFilter;
            });
        }

        // Helper function to check if a URL is valid
        function isValidUrl(string) {
            try {
                // Check if string is empty or just whitespace
                if (!string || string.trim() === '') {
                    return false;
                }

                // Check if it's a relative URL starting with /
                if (string.startsWith('/')) {
                    return true;
                }

                // Check using URL constructor
                const url = new URL(string);
                return url.protocol === 'http:' || url.protocol === 'https:' || url.protocol === 'data:';
            } catch (_) {
                return false;
            }
        }

        // Load initial animations (either from API or fallback)
        async function loadAnimations() {
            try {
                // Reset animation arrays
                allAnimations = [];
                animationsData = [];

                // Try to fetch from API first
                console.log("Fetching initial animations from API (true lazy loading)...");

                // Show loading state with modern indicator
                const grid = document.getElementById('animation-grid');
                if (grid) {
                    grid.innerHTML = `
                        <div class="loading-container" style="padding: 40px; text-align: center;">
                            <div class="loading-dots">
                                <div class="loading-dot"></div>
                                <div class="loading-dot"></div>
                                <div class="loading-dot"></div>
                            </div>
                            <p style="margin-top: 16px; color: var(--light-text);">Loading animations...</p>
                        </div>
                    `;
                } else {
                    console.error("Error: animation-grid element not found!");

                    // Try to recreate the grid container
                    const container = document.getElementById('animations-container');
                    if (container) {
                        console.log("Recreating animation grid container");
                        const newGrid = document.createElement('div');
                        newGrid.id = 'animation-grid';
                        newGrid.className = 'animation-grid';
                        container.appendChild(newGrid);
                    } else {
                        console.error("Error: animations-container element not found!");

                        // Add debug info to the body
                        const debugInfo = document.createElement('div');
                        debugInfo.style.padding = '20px';
                        debugInfo.style.color = 'red';
                        debugInfo.innerHTML = 'ERROR: Required containers not found. Please reload the plugin.';
                        document.body.appendChild(debugInfo);
                    }
                }

                // Reset pagination state for fresh start
                paginationState.currentPage = 1;
                paginationState.apiPage = 1;
                paginationState.hasMoreItems = true;
                paginationState.isLoading = true;
                paginationState.totalItems = 0;

                // Fetch only the first page of animations from API (with limit=12)
                const apiUrl = `https://www.ripplix.com/wp-json/ripplix/v1/animations?per_page=${paginationState.itemsPerPage}&page=${paginationState.apiPage}`;
                console.log(`Fetching first page: ${apiUrl}`);

                const response = await fetch(apiUrl);

                // Check if API request was successful
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                // Get total count from headers if available
                const totalItems = response.headers.get('X-WP-Total');
                if (totalItems) {
                    paginationState.totalItems = parseInt(totalItems, 10);
                    console.log(`Total animations available: ${paginationState.totalItems}`);

                    // Immediately update the count display
                    updateTotalCount();
                }

                // Parse API response
                const data = await response.json();
                console.log("API response data structure:", Object.keys(data));

                // Handle different API response formats
                let animations = [];

                // Case 1: API returns { animations: [...] }
                if (data && data.animations && Array.isArray(data.animations)) {
                    console.log("API returned data.animations array format");
                    animations = data.animations;
                }
                // Case 2: API returns an array directly
                else if (data && Array.isArray(data)) {
                    console.log("API returned direct array format");
                    animations = data;
                }
                // Case 3: Invalid format
                else {
                    console.warn("Invalid API response format:", data);
                    console.log("Using fallback data instead");
                    initWithFallbackData();
                    return;
                }

                if (animations.length === 0) {
                    console.warn("API returned empty animations array");
                    initWithFallbackData();
                    return;
                }

                console.log(`API returned ${animations.length} animations`);
                console.log("Sample animation:", animations[0]);

                // Process animations to standardize format
                const originalAnimations = animations;
                console.log("Processing API data with", originalAnimations.length, "animations");

                // Filter out animations with missing essential data
                const validAnimations = originalAnimations.filter(animation => {
                    return animation && animation.id && animation.title &&
                        (animation.video_url || animation.animation_url);
                });

                console.log(`Valid animations (with ID, title, and URL): ${validAnimations.length}`);

                // Process animations to standardize format
                const processedAnimations = validAnimations.map(animation => {
                    // Make sure URL is properly formatted
                    let videoUrl = animation.video_url || animation.animation_url || '';
                    if (videoUrl && videoUrl.includes('cloudflarestream')) {
                        videoUrl = fixCloudflareUrl(videoUrl);
                    }

                    // Standardize the animation object format
                    return {
                        id: animation.id.toString(),
                        title: animation.title || 'Untitled Animation',
                        platform: animation.platform || 'Web App',
                        interaction: Array.isArray(animation.interaction) ?
                            animation.interaction :
                            (typeof animation.interaction === 'string' ? [animation.interaction] : []),
                        url: animation.url || '',
                        video_url: videoUrl,
                        product: animation.product || 'Ripplix',
                        industry: animation.industry || '',
                        product_logo: animation.product_logo || '',
                        logo: animation.logo || animation.product_logo || ''
                    };
                });

                if (processedAnimations.length === 0) {
                    console.warn("No valid animations after processing, using fallback data");
                    initWithFallbackData();
                    return;
                }

                // Store just the first page of processed animations data
                allAnimations = processedAnimations;
                animationsData = [...allAnimations];
                console.log(`Loaded initial ${allAnimations.length} animations from API (of ${paginationState.totalItems} total)`);

                // Set flag to indicate more items are available
                paginationState.hasMoreItems = paginationState.totalItems > allAnimations.length;

                // Remove loading screen after initial animations load
                const loadingScreen = document.getElementById('fullscreen-loading');
                if (loadingScreen) {
                    loadingScreen.classList.add('hidden');
                    // Allow scrolling after a delay to ensure animation completes
                    setTimeout(() => {
                        document.body.style.overflow = '';
                    }, 600);
                }

                // Check if animation container exists
                const container = document.getElementById('animations-container');
                if (!container) {
                    console.error("animations-container not found after API fetch");

                    // Try to recreate container
                    const mainContent = document.querySelector('.main-content');
                    if (mainContent) {
                        const newContainer = document.createElement('div');
                        newContainer.id = 'animations-container';
                        mainContent.appendChild(newContainer);
                        console.log("Recreated animations-container");
                    }
                }

                // Create grid with the processed animations
                console.log("Creating animation grid with", allAnimations.length, "animations");
                createAnimationGrid(allAnimations);

                // Set up event handlers
                setupEventHandlers();

                // Make sure count is updated
                updateTotalCount();

                // Create loading indicator at the bottom of the grid for infinite scrolling
                createLoadMoreIndicator();
                positionLoadMoreSentinel();

                // Now that initial load is complete, set up the observer for lazy loading more items
                setupScrollListener();

            } catch (error) {
                console.error("Error loading animations from API:", error);
                console.log("Using fallback data instead");

                // Use fallback data if API fails
                initWithFallbackData();

                // Also hide loading screen if there was an error
                const loadingScreen = document.getElementById('fullscreen-loading');
                if (loadingScreen) {
                    loadingScreen.classList.add('hidden');
                    setTimeout(() => {
                        document.body.style.overflow = '';
                    }, 600);
                }
            } finally {
                paginationState.isLoading = false;

                // Ensure any loading indicators in the grid are removed
                const loadingContainer = document.querySelector('.loading-container');
                if (loadingContainer) {
                    loadingContainer.style.display = 'none';
                }

                // Check if the grid has content, if not, show a message
                const grid = document.getElementById('animation-grid');
                if (grid && grid.children.length === 0) {
                    console.warn("Grid is empty after loading!");
                    grid.innerHTML = '<div class="no-results">No animations loaded. Please try refreshing.</div>';
                }
            }
        }

        // Create loading indicator at the bottom of the grid
        function createLoadMoreIndicator() {
            const mainContent = document.querySelector('.main-content');
            if (!mainContent) return;

            // Create or update the loading more indicator
            let loadingMore = document.getElementById('loading-more');
            if (!loadingMore) {
                loadingMore = document.createElement('div');
                loadingMore.id = 'loading-more';
                loadingMore.className = 'loading-more';

                // Create loading dots
                const dotsContainer = document.createElement('div');
                dotsContainer.className = 'loading-dots';

                // Add three dots for animation
                for (let i = 0; i < 3; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'loading-dot';
                    dotsContainer.appendChild(dot);
                }

                // Add loading text
                const loadingText = document.createElement('div');
                loadingText.className = 'loading-text';
                loadingText.textContent = 'Loading more animations...';

                // Assemble the indicator
                loadingMore.appendChild(dotsContainer);
                loadingMore.appendChild(loadingText);

                mainContent.appendChild(loadingMore);
            }

            // Create a sentinel element for IntersectionObserver
            let sentinel = document.getElementById('load-more-sentinel');
            if (!sentinel) {
                sentinel = document.createElement('div');
                sentinel.id = 'load-more-sentinel';
                sentinel.style.height = '20px';
                sentinel.style.width = '100%';
                sentinel.style.visibility = 'hidden';
                mainContent.appendChild(sentinel);
            }
        }

        // Initialize with fallback data when API fails
        function initWithFallbackData() {
            console.log("Using fallback data");

            // Use the fallback data
            allAnimations = fallbackData.animations;
            animationsData = [...allAnimations];

            // Set pagination state for fallback data
            paginationState.totalItems = fallbackData.animations.length;

            // Create grid with the fallback animations
            createAnimationGrid(allAnimations);

            // Set up event handlers
            setupEventHandlers();

            // Update count display with fallback data
            updateTotalCount();

            // Remove loading screen
            const loadingScreen = document.getElementById('fullscreen-loading');
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');
                setTimeout(() => {
                    document.body.style.overflow = '';
                }, 600);
            }

            // Create load more indicator (even though we won't have more with fallback)
            createLoadMoreIndicator();
            positionLoadMoreSentinel();

            // Set up scroll listener for UI interactions
            setupScrollListener();
        }

        // Initialize the UI with animations
        function initAnimations() {
            // Store clean copy for filtering
            animationsData = [...allAnimations];

            // Reset the grid
            const grid = document.getElementById('animation-grid');
            if (grid) {
                // Clear the grid completely
                grid.innerHTML = '';

                // Add animations to the grid
                displayAnimations();
            }

            // Remove any stray loading indicators
            const loadingContainers = document.querySelectorAll('.loading-container');
            loadingContainers.forEach(container => {
                container.style.display = 'none';
            });

            // Set up event handlers
            setupEventHandlers();

            // Show total count
            updateTotalCount();
        }

        // Display animations in the grid
        function displayAnimations() {
            // Get the grid
            const grid = document.getElementById('animation-grid');
            if (!grid) return;

            // Reset pagination
            paginationState.currentPage = 1;

            // Clear the grid
            grid.innerHTML = '';

            // Get visible animations after filters
            const visibleAnimations = getVisibleAnimations();

            // Add each animation to the grid
            if (visibleAnimations.length > 0) {
                visibleAnimations.forEach(animation => {
                    const card = createAnimationCard(animation);
                    if (card) {
                        grid.appendChild(card);
                    }
                });

                // Initialize lazy loading for videos and images - performance optimized
                initLazyLoading();

                // Update the animation count display
                updateAnimationCount(visibleAnimations.length);

                // Ensure load more sentinel is positioned correctly
                positionLoadMoreSentinel();

                // Check if we need to load more
                if (visibleAnimations.length < paginationState.itemsPerPage) {
                    // We have fewer animations than a full page
                    if (paginationState.hasMoreItems) {
                        // Try to load more since we have fewer than a page
                        setTimeout(loadMoreAnimations, 500);
                    }
                }
            } else {
                // Show no results message
                grid.innerHTML = '<div class="no-results">No animations match your search. Try different filters or search terms.</div>';

                // Hide load more sentinel
                const sentinel = document.getElementById('load-more-sentinel');
                if (sentinel) {
                    sentinel.style.display = 'none';
                }
            }
        }

        // Create the sentinel element for infinite scrolling detection
        function createLoadMoreSentinel() {
            // Create or get the sentinel element
            let sentinel = document.getElementById('load-more-sentinel');
            if (!sentinel) {
                sentinel = document.createElement('div');
                sentinel.id = 'load-more-sentinel';
                sentinel.style.height = '20px';
                sentinel.style.width = '100%';
                sentinel.style.margin = '20px 0';
                sentinel.style.visibility = 'hidden';

                // Add it to the DOM
                const mainContent = document.querySelector('.main-content');
                if (mainContent) {
                    mainContent.appendChild(sentinel);
                }
            }
        }

        // Fallback scroll listener for browsers without IntersectionObserver
        function setupFallbackScrollListener() {
            console.log("Using fallback scroll listener");

            // Function to check scroll position and load more if needed
            function checkScrollPosition() {
                if (paginationState.isLoading || !paginationState.hasMoreItems) return;

                // Get scroll position and document height
                const scrollPosition = window.scrollY + window.innerHeight;
                const totalHeight = document.body.scrollHeight;

                // Load more when close to bottom
                const threshold = 200; // px from bottom
                if (scrollPosition + threshold >= totalHeight) {
                    loadMoreAnimations();
                }
            }

            // Throttle scroll event to avoid performance issues
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                if (scrollTimeout) clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(checkScrollPosition, 100);
            }, {
                passive: true
            });

            // Initial check after content is loaded
            setTimeout(checkScrollPosition, 500);
        }

        // Set up filter UI based on API data
        function setupFilters(animations) {
            console.log("Setting up filters based on animations data");

            // Extract unique interaction types from all animations
            const interactionTypes = extractUniqueInteractions(animations);
            console.log("Unique interaction types:", interactionTypes);

            // Update filter tags with these interaction types
            updateInteractionFilterTags(interactionTypes);

            // Also extract platforms for the dropdown
            const platforms = extractUniquePlatforms(animations);
            console.log("Unique platforms:", platforms);

            // Update platform dropdown
            updatePlatformDropdown(platforms);
        }

        // Update platform dropdown with API data
        function updatePlatformDropdown(platforms) {
            const platformSelect = document.getElementById('platform-select');
            if (!platformSelect) return;

            // Clear existing options except the first "All" option
            while (platformSelect.options.length > 1) {
                platformSelect.remove(1);
            }

            // Add new platform options
            platforms.forEach(platform => {
                const option = document.createElement('option');
                option.value = platform;
                option.textContent = platform;
                platformSelect.appendChild(option);
            });
        }

        // Extract unique interaction types from animations
        function extractUniqueInteractions(animations) {
            const interactionSet = new Set();

            animations.forEach(animation => {
                if (Array.isArray(animation.interaction)) {
                    animation.interaction.forEach(interaction => {
                        if (interaction && typeof interaction === 'string' && interaction.trim()) {
                            interactionSet.add(interaction.trim());
                        }
                    });
                } else if (animation.interaction && typeof animation.interaction === 'string' && animation.interaction.trim()) {
                    interactionSet.add(animation.interaction.trim());
                }
            });

            // Convert set to array and sort alphabetically
            return Array.from(interactionSet).sort();
        }

        // Extract unique platforms from animations
        function extractUniquePlatforms(animations) {
            const platformSet = new Set();

            animations.forEach(animation => {
                if (animation.platform && typeof animation.platform === 'string' && animation.platform.trim()) {
                    platformSet.add(animation.platform.trim());
                }
            });

            // Convert set to array and sort alphabetically
            return Array.from(platformSet).sort();
        }

        // Update interaction filter tags based on API data
        function updateInteractionFilterTags(interactions) {
            console.log("Setting up interaction filters with data:", interactions);
            const filterContainer = document.getElementById('filter-container');
            if (!filterContainer) {
                console.error("Error: filter-container not found");
                return;
            }

            // Clear existing filters
            filterContainer.innerHTML = '';

            // Sort interactions alphabetically for better organization
            interactions.sort();

            // Add all interaction types (no limit)
            interactions.forEach(interaction => {
                if (interaction && typeof interaction === 'string') {
                    addInteractionFilterTag(filterContainer, interaction);
                }
            });

            // Re-attach event listeners
            setupFilterTagEventListeners();

            // Set up scroll buttons
            setupFilterScrollButtons();

            console.log(`Total filter tags created: ${filterContainer.querySelectorAll('.filter-tag').length}`);
        }

        // Setup horizontal scroll buttons for filters
        function setupFilterScrollButtons() {
            const filterContainer = document.getElementById('filter-container');
            const scrollLeftBtn = document.getElementById('scroll-left');
            const scrollRightBtn = document.getElementById('scroll-right');

            if (!filterContainer || !scrollLeftBtn || !scrollRightBtn) {
                console.log("One or more elements for filter scrolling not found yet");
                return;
            }

            console.log("Setting up filter scroll buttons");

            // Set initial button states
            updateScrollButtonsVisibility();

            // Handle left scroll
            scrollLeftBtn.addEventListener('click', () => {
                // Scroll left by 200px (about 3-4 tags)
                filterContainer.scrollBy({
                    left: -200,
                    behavior: 'smooth'
                });
            });

            // Handle right scroll
            scrollRightBtn.addEventListener('click', () => {
                // Scroll right by 200px (about 3-4 tags)
                filterContainer.scrollBy({
                    left: 200,
                    behavior: 'smooth'
                });
            });

            // Update button states on scroll
            filterContainer.addEventListener('scroll', updateScrollButtonsVisibility);

            // Update button states on window resize
            window.addEventListener('resize', updateScrollButtonsVisibility);

            // Function to update button states based on scroll position
            function updateScrollButtonsVisibility() {
                // Check if we're at the left edge
                if (filterContainer.scrollLeft <= 0) {
                    scrollLeftBtn.style.opacity = '0.5';
                    scrollLeftBtn.style.pointerEvents = 'none';
                } else {
                    scrollLeftBtn.style.opacity = '1';
                    scrollLeftBtn.style.pointerEvents = 'auto';
                }

                // Check if we're at the right edge
                if (filterContainer.scrollLeft + filterContainer.clientWidth >= filterContainer.scrollWidth - 5) {
                    scrollRightBtn.style.opacity = '0.5';
                    scrollRightBtn.style.pointerEvents = 'none';
                } else {
                    scrollRightBtn.style.opacity = '1';
                    scrollRightBtn.style.pointerEvents = 'auto';
                }
            }
        }

        // Add a single interaction filter tag
        function addInteractionFilterTag(container, interaction) {
            const tag = document.createElement('span');
            tag.className = 'filter-tag';
            tag.setAttribute('data-filter', 'interaction');
            tag.setAttribute('data-value', interaction);
            tag.textContent = interaction;
            container.appendChild(tag);

            // Check if this interaction is currently active
            if (activeFilters.interaction === interaction) {
                tag.classList.add('active');
            }
        }

        // Re-attach event listeners to filter tags
        function setupFilterTagEventListeners() {
            const filterTags = document.querySelectorAll('.filter-tag');
            console.log(`Setting up event listeners for ${filterTags.length} filter tags`);

            filterTags.forEach(tag => {
                // Add click handler
                tag.addEventListener('click', () => {
                    const filterType = tag.getAttribute('data-filter');
                    const filterValue = tag.getAttribute('data-value');
                    console.log(`Filter tag clicked: ${filterType}=${filterValue}`);

                    // Check if this tag is already active
                    const isAlreadyActive = tag.classList.contains('active');

                    // Clear all active filters of this type first - reset styling
                    document.querySelectorAll(`.filter-tag[data-filter="${filterType}"]`).forEach(t => {
                        t.classList.remove('active');
                        // Reset all inline styles
                        t.style.backgroundColor = '';
                        t.style.color = '';
                        t.style.borderColor = '';
                    });

                    // Clear the filter value
                    activeFilters[filterType] = null;

                    // If this wasn't the active tag, make it active
                    if (!isAlreadyActive) {
                        // Set the new filter
                        activeFilters[filterType] = filterValue;
                        console.log(`Set filter: ${filterType}=${filterValue}`);

                        // Update tag style
                        tag.classList.add('active');
                    } else {
                        console.log(`Cleared filter: ${filterType} - showing all animations`);
                    }

                    // Apply filters immediately
                    applyFilters();
                });

                // Add hover effect logic
                tag.addEventListener('mouseover', () => {
                    if (!tag.classList.contains('active')) {
                        tag.style.backgroundColor = '#FFFFFF';
                        tag.style.color = '#000000';
                        tag.style.borderColor = '#EBEBEB';
                    }
                });

                tag.addEventListener('mouseout', () => {
                    if (!tag.classList.contains('active')) {
                        tag.style.backgroundColor = '';
                        tag.style.color = '';
                        tag.style.borderColor = '';
                    }
                });
            });
        }

        // Reset plugin to initial state
        function resetToInitialState() {
            console.log("Resetting plugin to initial state");

            // Clear search input
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                searchInput.value = '';
            }

            // Reset platform filter
            const platformSelect = document.getElementById('platform-select');
            if (platformSelect) {
                platformSelect.value = '';
            }

            // Reset active filters
            activeFilters = {
                platform: null,
                interaction: null
            };

            // Remove active class from all filter tags
            document.querySelectorAll('.filter-tag').forEach(tag => {
                tag.classList.remove('active');
                // Reset all inline styles
                tag.style.backgroundColor = '';
                tag.style.color = '';
                tag.style.borderColor = '';
            });

            // Reset pagination state to show all results
            paginationState.currentPage = 1;

            // Make sure the full count is shown in the UI
            const totalAnimations = paginationState.totalItems || allAnimations.length;

            const countElement = document.getElementById('animation-count');
            const countLabel = document.getElementById('count-label');
            const originalCountEl = document.getElementById('original-count');

            if (countElement) {
                // Format count for display
                let formattedCount = totalAnimations;
                if (totalAnimations >= 1000) {
                    formattedCount = (totalAnimations / 1000).toFixed(1) + "K";
                }
                countElement.textContent = formattedCount;
            }

            if (countLabel) {
                countLabel.textContent = "Animations";
            }

            if (originalCountEl) {
                originalCountEl.style.display = 'none';
            }

            // Force the loading of all animations by setting isFiltered to false
            document.getElementById('filter-container').setAttribute('data-reset', 'true');

            // Make sure totalItems reflects all animations
            if (paginationState.totalItems < allAnimations.length) {
                paginationState.totalItems = allAnimations.length;
            }

            // Ensure the sentinel is visible for infinite scrolling
            const sentinel = document.getElementById('load-more-sentinel');
            if (sentinel) {
                sentinel.style.display = '';
            }

            // Reset animations data
            animationsData = [...allAnimations];

            // Apply filters (with all filters cleared)
            // This will rebuild the grid with all animations
            applyFilters();

            // Remove the reset marker after filtering is complete
            setTimeout(() => {
                document.getElementById('filter-container').removeAttribute('data-reset');
            }, 100);

            // Scroll to top
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
    </script>
</body>

</html>